package BDQC::UI;

###############################################################################
# Class       : BDQC::UI
#
# Description : This class is autogenerated via generatePerlClasses.pl and
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::UI';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';

#### BEGIN CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE
use Data::Dumper;


#### END CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Process constructor object parameters

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub outlierDetails {
###############################################################################
# outlierDetails
###############################################################################
  my $METHOD = 'outlierDetails';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub viewOutliers {
###############################################################################
# viewOutliers
###############################################################################
  my $METHOD = 'viewOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}

sub parseParameters {
  # Custom sub written to avoid dependence on CGI.pm 
  my $self = shift;
  my %params;
  if ( $ENV{QUERY_STRING} ) {
    my @params = split( /[&;]/, $ENV{QUERY_STRING} );
    for my $param ( @params ) {
      my ( $k, $v ) = split( /=/, $param );
      $params{$k} = $v;
    }
  }
  $self->{params} = \%params;
  return \%params;
}

sub getHeader {
  my $self = shift;
  return qq~Content-Type: text/html; charset=ISO-8859-1

~;
}

sub startPage {
  my $self = shift;
  my $start = qq~
<html>
 <head></head>
  <body onload="drawplot()">
  ~;
  return $start;
}

sub getModelSelect {
  my $self = shift;
  my $models = shift || return "";
  my $msel = "<select id=plotselect onchange=drawplot()>\n";                   
  my $has_opts;
  for my $m ( sort { $a cmp $b } ( keys( %{$models} ) ) ) {
    next if $models->{$m}->{data}->[0]->{dataType} eq 'string';
    $msel .= "<option id='$m'>$m</option>\n";
    $has_opts++;
  }
  $msel .= "</select>\n";
  return ( $has_opts ) ? $msel : '';
}

sub getPlotHTML {
  my $self = shift;
  my %args = @_;
  return '' unless $args{params} && $args{models};
  $args{select} ||= $self->getModelSelect( $args{models} );

  my %style = ( 1 => 'all',
                2 => 'suspectedoutliers',
                3 => 'Outliers' );

  $args{params}->{style} ||= 1;

  my $HTML = qq~
  <script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <form name=plot id=plot>
  <h3> Select Model to View: $args{select} </h3>
  </form>
  <div id="plot_div" style="width:800px;height:600;"></div>
  <script type="text/javascript" charset="utf-8">
  function drawplot () {
    var models = [];
    var hover = [];
  ~;

  for my $m ( sort { lc($a) <=> lc($b) } ( keys( %{$args{models}} ) ) ) {
    my @data;
    my @flag;
    for my $d ( @{$args{models}->{$m}->{data}} ) {
      push @data, $d->{value};  
      push @flag, $d->{deviationFlag};  
    }
    my $dstr = join( ',', @data );
    $HTML .= "models['$m'] = [$dstr]\n"; 
    my $lblstr = join( "','", @flag );
    $HTML .= "hover['$m'] = ['$lblstr']\n"; 

  }
  $HTML .= qq~

    var model = document.getElementById("plotselect").value;

    var plotdata = [
    {
      y: models[model],
      hoverinfo: 'all',
      hoveron: 'points',
      customdata: hover[model],
//      y: [530887,485892,607403,604229,614625,106103,271216,545388,707144,666517,165958,569102,542880],
//      y: [0.75, 5.25, 5.5, 6, 6.2, 6.6, 6.80, 7.0, 7.2, 7.5, 7.5, 7.75, 8.15, 8.15, 8.65, 8.93, 9.2, 9.5, 10, 10.25, 11.5, 12, 16, 20.90, 22.3, 23.25],

      type: 'box',
      boxpoints: '$style{$args{params}->{style}}',
      name: model,
      marker: {
       color: 'rgb(8,81,156)',
       outliercolor: 'rgba(219, 64, 82, 0.6)',
       line: {
         outliercolor: 'rgba(219, 64, 82, 1.0)',
         outlierwidth: 2
       }
      }
    }
    ]
    Plotly.newPlot('plot_div', plotdata);
  }
  </script>
  ~;
  return $HTML;
}

sub endPage {
  my $self = shift;
  my $end = qq~
  </html>
  ~;
  return $end;
}

1;
