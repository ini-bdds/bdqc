package BDQC::UI;

###############################################################################
# Class       : BDQC::UI
#
# Description : This class is autogenerated via generatePerlClasses.pl and
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::UI';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';

#### BEGIN CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE
use Data::Dumper;


#### END CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Process constructor object parameters

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub outlierDetails {
###############################################################################
# outlierDetails
###############################################################################
  my $METHOD = 'outlierDetails';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub viewOutliers {
###############################################################################
# viewOutliers
###############################################################################
  my $METHOD = 'viewOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}

sub parseParameters {
  # Custom sub written to avoid dependence on CGI.pm 
  my $self = shift;
  my %params;
  if ( $ENV{QUERY_STRING} ) {
    $params{cgimode} = 1;
    $params{writeHTML} = 1;
    my @params = split( /[&;]/, $ENV{QUERY_STRING} );
    for my $param ( @params ) {
      my ( $k, $v ) = split( /=/, $param );
      $params{$k} = $v;
    }
  }
  $self->{params} = \%params;
  return \%params;
}

sub getHeader {
  my $self = shift;
  return qq~Content-Type: text/html; charset=ISO-8859-1

~;
}

sub startPage {
  my $self = shift;
  my $start = qq~
<html>
 <head></head>
  <body onload="drawplot()">
    <style>
     .banner {
       position:fixed;
       display:inline-block;
       white-space:nowrap;
       width:100%;
       min-height:70px;
       z-index:95;
       font-size:20px;
       color:#ffffff;
       background-color:#003F72;
       box-shadow: 0 6px 8px 0 rgba(0,0,0,0.3);
     }
     .banner::after {
       font-size:50px;
       right:10px;top:0px;
       position:absolute;
       color:rgba(255,255,255,0.3);
       font-weight:bold;
       letter-spacing:15px;
       content:attr(banner-bg-text);
       pointer-events:none;
     }
  </style>
  <div class='banner' banner-bg-text='BDQC'>
  <span title="Banner designed for TPP by L. Mendoza">&nbsp;<span>
  </div>
  ~;
  return $start;
}

sub getModelSelect {
  my $self = shift;
  my $models = shift || return "";
  my $use_nl = shift;
  $use_nl = 1 if !defined $use_nl;
  my $sep = ( $use_nl ) ? "\n" : ' ';

  my $msel = "<select id=plotselect onchange=drawplot()>$sep";                   
  my $has_opts;
  for my $m ( sort { $a cmp $b } ( keys( %{$models} ) ) ) {
    next if $m eq 'files';
#    next if $models->{$m}->{data}->[0]->{dataType} eq 'string';
    $msel .= qq~<option id="$m">$m</option>$sep~;
    $has_opts++;
  }
  $msel .= "</select>$sep";
  return ( $has_opts ) ? $msel : '';
}

sub getModelSelectFunction {
  my $self = shift;
  my $models = shift || return "";
  my $js = qq~
  <script type="text/javascript" charset="utf-8">
  function setmodel () {
    var model = document.getElementById("ftselect").value;
    var msel = [];
  ~;
  for my $ft ( sort ( keys( %{$models} ) ) ) {
    my $mod = $models->{$ft};
    my $mselect = "'" . $self->getModelSelect( $mod, 0 ) . "'";
#    $mselect =~ s/\s//g;
#    $mselect =~ s/\n//g;
    $js .= " msel['$ft'] = $mselect;\n";
  }
  $js .= qq~
    document.getElementById("mseldiv").innerHTML = msel[model];
  }
  function showSignaturePlot( type, model ) {
//    alert( type );
//    alert( document.getElementById("ftselect").selectedIndex );
    document.getElementById("ftselect").value = type
//    alert( document.getElementById("ftselect").selectedIndex );
    setmodel();
//    alert(model);
//    alert( document.getElementById("plotselect").selectedIndex );
    var psel = document.getElementById("plotselect");
    var i;
    var txt = "All options:  \\n";
    for ( i = 0; i < psel.length; i++ ) {
      txt = txt + "\\n" + psel.options[i].value;
    }
//    alert( txt );

//    alert( document.getElementById("plotselect").value );
    document.getElementById("plotselect").value = model;
    drawplot();
//    alert( document.getElementById("plotselect").selectedIndex );
  }
  </script>
  ~;
  return $js;
}


###

sub getFiletypeSelect {
  my $self = shift;
  my $models = shift || return "";
  my $ftsel = "<select id=ftselect onchange='setmodel();drawplot()'>\n";                   
  my $has_opts;
  for my $ft ( sort ( keys( %{$models} ) ) ) {
    my $has_data = 0;
    for my $m ( keys( %{$models->{$ft}} ) ) {
      next if $m eq 'files';
      $has_data++;
    }
    next unless $has_data;

    $ftsel .= "<option id='$ft'>$ft</option>\n";
    $has_opts++;
  }
  $ftsel .= "</select>\n";
  return ( $has_opts ) ? $ftsel : '';
}


sub getPlotHTML {
  my $self = shift;
  my %args = @_;
  my $kb = $args{kb} || die;
  return '' unless $args{params} && $args{models};
  $args{msel} ||= $self->getModelSelect( $args{models} );

  my %style = ( 1 => 'all',
                2 => 'suspectedoutliers',
                3 => 'Outliers' );

  $args{params}->{style} ||= 1;

#  <tr><td><b>Models to consider:</b></td><td>$args{msensitivity}</td></tr>
#  <div id=heatmap_div style="width:600px;height:400px;border-style:solid;border-color:gray;border-width:2px"></div>
#  <div id=heatmap_div style="border-style:solid;border-color:gray;border-width:2px"></div>

  my $HTML = qq~
  <div id=top_div></div>
  $args{title}

  <script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  $args{msel_fx}
  <br><br>

  <br><br>
  <form name=plot id=plot>
  <table>
  <tr><td align=right>Choose FileType:</td><td>$args{ftsel}</td></tr>
  <tr><td>Select Model to View:</td><td>$args{msel}</td></tr>
  </table>
  </form>
  <style>
  .container {
    display: inline-block;
  }
  .emphasis {
    font-family: arial;
    font-size: 20px;
  }
  </style>
  <div class="container">
  <div id=heatmap_div style="width:450;height:300px;border-style:solid;border-color:gray;border-width:2px;float:left"></div>
  <div id="plot_div" style="width:450;height:300px;border-style:solid;border-color:gray;border-width:2px;float:left"></div>
  </div>
  <script type="text/javascript" charset="utf-8">
  function drawplot () {
    var models = [];
    var hover = [];
    var jitter = [];
    var modelAnnot = [];
    var color = [];
    var friendly = [];
    var heatX = [];
    var heatY = [];
    var heatZ = [];
    var heatAnnot = [];
  ~;

  my $outliers = $args{outliers};
  my $tmpl = $outliers->{templates}->{friendly};
  
  my %heater;
  my %hfiles;
  my %hmodels;
  my $hmin = 100;
  my $hmax = 0;
  my @mkeys = sort(keys( %{$args{models}} ) );
  my %fcnt;
  for my $ft ( @mkeys ) {
    my $currmodel = $args{models}->{$ft};
    $HTML .= qq~
    models['$ft'] = [];
    hover['$ft'] = [];
    jitter['$ft'] = [];
    color['$ft'] = [];
    friendly['$ft'] = [];
    ~;
    $fcnt{$ft} = scalar( @{$args{models}->{$ft}->{files}} );
    $heater{$ft} = [];
    $hmodels{$ft} = [];
    $hfiles{$ft} = [];


    for my $file ( @{$args{models}->{$ft}->{files}} ) {
      push @{$hfiles{$ft}}, $file;
    }
    for my $m ( sort { lc($a) cmp lc($b) } ( keys( %{$currmodel} ) ) ) {
      next if $m eq 'files';
      my $fsig = $kb->{_qckb}->{signatureInfo}->{$m}->{friendlyName} || $m; 
      $HTML .= "friendly['$fsig'] = '$m'\n";

      push @{$hmodels{$ft}}, $fsig;

      my @data;
      my @flag;
      my @jitter;
      my @color;
      my $sign = 1;
  
      my $n = 'rgb(8,81,156)';
      my $e = 'rgb(255,255,0)';
      my $o = 'rgb(219,64,82)';
  
      my @heatrow;
      for my $d ( @{$currmodel->{$m}->{data}} ) {
        
        my $devn = abs($d->{deviation});

        #### limit the deviations for the heat map to max of 19, null to 20
        $devn = 19 if ( $devn > 19 );
        $devn = 20 if ( !defined($d->{datum}) || $d->{datum} eq '(null)' );

        push @heatrow, $devn;
        $hmax = $devn if $devn > $hmax;
        $hmin = $devn if $devn < $hmin;
        push @data, $d->{value};  
        my $hlbl = ( $d->{filetag} ) ? "$d->{filetag}: $d->{deviationFlag}" : $d->{deviationFlag};  
        $hlbl = " Value: $d->{datum}<br> $hlbl" if ( defined($d->{value}) && $d->{datum} ne $d->{value} );

        push @flag, $hlbl;
        push @color, ( $d->{deviationFlag} eq 'normal' ) ? $n :
                     ( $d->{deviationFlag} eq 'outlier' ) ? $o : $e;
        push @jitter, $sign*rand(0.2)/10;
        $sign = ( $sign == 1 ) ? -1 : 1;
      }
      push @{$heater{$ft}}, \@heatrow;
      my @cdata;
      my $ncnt = 0;
      for my $d ( @data ) {
        if ( !defined $d ) {
          $ncnt++;
          $d = '' 
        }
        push @cdata, $d;
      }
      my $dstr = join( ',', @cdata );
      my $nullinfo = ' ';
      if ( $ncnt ) {
        $nullinfo = "($ncnt null values are not displayed)";
      }
      $HTML .= "modelAnnot['$m'] = '$nullinfo'\n";
  
      $HTML .= "models['$ft']['$m'] = [$dstr]\n"; 
      my $lblstr = join( "','", @flag );
      $HTML .= "hover['$ft']['$m'] = ['$lblstr']\n"; 
      my $colorstr = join( "','", @color );
      $HTML .= "color['$ft']['$m'] = ['$colorstr']\n"; 
      my $jitterstr = join(',', @jitter );
      $HTML .= "jitter['$ft']['$m'] = [$jitterstr]\n"; 
  
    }
  }

  #### Cluster the models
  my $heatmapHTML = '';
  for my $ft ( keys( %heater ) ) {
    my $clusterResult = cluster( matrix => $heater{$ft} );
    @{$heater{$ft}} = @{$clusterResult->{clusteredArray}};
    my @newOrder = @{$clusterResult->{clusteredOrder}};
    my @reorderedModels;
    foreach my $index ( @newOrder ) {
      push(@reorderedModels,$hmodels{$ft}->[$index]);
    }
    @{$hmodels{$ft}} = @reorderedModels;


    #### Cluster the files if there are fewer than 500. doing this for a large number of files
    #### takes too long with this slow code. make it faster and allow more.
    if ( scalar(@{$hfiles{$ft}}) <= 500 ) {

      my $pivotResult = pivot( matrix => $heater{$ft} , direction=>1 );
      $clusterResult = cluster( matrix => $pivotResult->{matrix} );
      my $dePivotResult = pivot( matrix => $clusterResult->{clusteredArray} , direction=>-1 );
      @{$heater{$ft}} = @{$dePivotResult->{matrix}};
      @newOrder = @{$clusterResult->{clusteredOrder}};
      my @reorderedFiles;
      foreach my $index ( @newOrder ) {
        push(@reorderedFiles,$hfiles{$ft}->[$index]);
      }
      @{$hfiles{$ft}} = @reorderedFiles;
    }

    my $hfilestr = "['" . join( "','", @{$hfiles{$ft}} ) . "']";
    my $hmodelstr = "['" . join( "','", @{$hmodels{$ft}} ) . "']";
    my $hdatastr = '[';
    my $sep = '';
    for my $hrow ( @{$heater{$ft}} ) {
      no warnings 'uninitialized';
      $hdatastr .= $sep . '[' . join( ',', @{$hrow} ) . ']';
      $sep = ',';
    }
    $hdatastr .= ']';
    $heatmapHTML .= qq~
    heatX['$ft'] = $hfilestr;
    heatY['$ft'] = $hmodelstr;
    heatZ['$ft'] = $hdatastr;
    ~;
  }

  $HTML .= qq~
    $heatmapHTML

    var ft = document.getElementById("ftselect").value;
    var model = document.getElementById("plotselect").value;

    var plotdata = [
    {
      y: models[ft][model],
      x: jitter[ft][model],
      text: hover[ft][model],
      hovermode: 'closest',
      hoverinfo: 'y+text',
      type: 'scatter',
      mode: 'markers',
      marker: { color: color[ft][model] },
      showlegend: false,
      showticklabels: false,
    },
    {
      y: models[ft][model],
      type: 'box',
      boxpoints: false,
      showticklabels: false,
      hoverinfo: 'none',
      name: model,
      marker: {
       color: 'rgb(8,81,156)',
      },
//       outliercolor: 'rgba(219, 64, 82, 0.6)',
//       line: {
//         outliercolor: 'rgba(219, 64, 82, 1.0)',
//         outlierwidth: 2
//       }
//      }
    }
    ]
    var title = '<b>' + model + '</b><br>' + modelAnnot[model];

    Plotly.newPlot('plot_div', plotdata, { title: title, showlegend: false, hovermode: 'closest', xaxis: { showticklabels: false }, margin: { l: 40, r: 30, t: 50, b: 30 }
        
        } );

var colorscaleValue = [
  [.0, '#FFFFFF'],
  [.1, '#DDDDDD'],
  [.2, '#BBBBBB'],
  [.3, '#999999'],
  [.4, '#777777'],
  [.5, '#555555'],
  [.96, '#FF0000'],
  [1., '#FFFF99']
];

var hdata = [{
  x: heatX[ft],
  y: heatY[ft],
  z: heatZ[ft],
  zmin: 0,
  zmax: 20,
  type: 'heatmap',
  colorscale: colorscaleValue,
  showscale: true
}];

var hlayout = {
  title: ft + ' outlier heatmap (files vs models)',
  annotations: [],
  xaxis: {
    showticklabels: false,
    ticks: '',
  },
  yaxis: {
    ticks: '',
    showticklabels: false,
    ticksuffix: ' ',
  },
  margin: {
  l: 30,
  r: 30,
  t: 50,
  b: 30
  }
};

Plotly.newPlot('heatmap_div', hdata, hlayout);

  var heater = document.getElementById( 'heatmap_div' );
  heater.on( 'plotly_click', function(data) {
      var pn = '';
      var tn = '';
      for ( var i=0; i<data.points.length; i++ ) {
        pn = data.points[i].pointNumber;
        tn = data.points[i].curveNumber;
      }
      var type = document.getElementById("ftselect").value;
//    alert( document.getElementById("ftselect").selectedIndex );
//      alert(pn[0]);
//      alert(pn[1]);
//      alert( heatY[type][pn[0]] );
//      alert( friendly[heatY[type][pn[0]]] );
      var psel = document.getElementById("plotselect");
      var i;
      for ( i = 0; i < psel.length; i++ ) {
//        if ( psel.options[i].value ==  friendly[heatY[type][pn[0]]] ) {
        if ( psel.options[i].value ==  heatY[type][pn[0]] ) {
          psel.selectedIndex = i;
          break;
        }
      }
      showSignaturePlot(type,psel.options[psel.selectedIndex].value);
  });

  }

  function toggleView ( type ) {
    if ( document.getElementById(type).style.display == 'none' ) {
      document.getElementById(type).style.display = 'inline-block';
    } else {
      document.getElementById(type).style.display = 'none';
    }
  }
  </script>
  <h3 style=text-decoration:underline> File types with outliers</ul> </h3>
  ~;
#        annotations: [{ showarrow: false,xanchor: 'left', yanchor: 'top', text: modelAnnot[model] } ],

  my $fcnt;
  
  my $sp = "&nbsp;&nbsp;";
  foreach my $fileType ( sort keys(%{$outliers->{fileTypes}}) ) {
    my $nOutliers = 0;
    my $outlierHTML = '';

    foreach my $outlierFileTagName ( sort keys(%{$outliers->{fileTypes}->{$fileType}->{fileTags}}) ) {
      my $outlierFileTagList = $outliers->{fileTypes}->{$fileType}->{fileTags}->{$outlierFileTagName};
      my $nOutlierFlags = scalar(@{$outlierFileTagList});
      my $nOutlierFiles = 0;
      $nOutlierFiles++;
      $nOutliers += $nOutlierFiles;
      my $nOutlierText = ( $nOutlierFlags > 1 ) ? $nOutlierFlags . ' flags' : $nOutlierFlags . ' flag' ;

      $outlierHTML .= $tmpl->{HeadTemplate} . "<br>\n"; 
      $outlierHTML =~ s/FILETAG/$outlierFileTagName/gm;
      $outlierHTML =~ s/NOUTLIERFLAGS/$nOutlierText/gm;

      foreach my $outlier ( @{$outlierFileTagList} ) {
        my $signature = $outlier->{signature};
        my $attribute = $outlier->{attribute};
        my $fsig = $kb->{_qckb}->{signatureInfo}->{"$signature.$attribute"}->{friendlyName} || "$signature.$attribute";
        my $value = $outlier->{value};
        my $deviation = $outlier->{deviation}->{deviation};
        $deviation = sprintf( "%0.1f", $deviation);
        $value = '(null)' if ( ! defined($value) );
        $value = substr($value,0,70)."...." if ( length($value)>74 );

        my $noun_link = qq~<a href="#top_div" onclick="showSignaturePlot('$fileType','$fsig')">$fsig</a>~;
        my $side = ( $deviation > 0 ) ? 'upper' : 'lower';
        my $verb = $kb->{_qckb}->{signatureInfo}->{"$signature.$attribute"}->{sideName}->{$side} || "different";

        my $itemHTML = $tmpl->{ItemTemplate} . "<br>\n";
        $itemHTML =~ s/NOUN/$noun_link/gm;
        $itemHTML =~ s/VERB/$verb/gm;
        $outlierHTML .= $itemHTML;
      }
    }

    if ( $nOutliers ) {
      $HTML .= qq~$sp<b>File Type: $fileType</b>, <a href="javascript:void(0);" onclick="toggleView('${fileType}_div')"> $nOutliers outliers</a> out of $fcnt{$fileType} files<br>\n~;
      $HTML .= qq~$sp$sp$sp<div id="${fileType}_div" style='display:none;border-style:dashed;border-color:gray;border-width:2px'>$outlierHTML</div><br>\n~;
    } else {
      $HTML .= qq~$sp<b>File Type: $fileType</b>, $nOutliers outliers out of $fcnt{$fileType} files <br>\n~;
      $HTML .= qq~<div width=800 id="no_div" style='display: inline'>$outlierHTML</div><br>\n~;
    }
  }
  return $HTML;
}

sub endPage {
  my $self = shift;
  my $end = qq~
  </html>
  ~;
  return $end;
}


sub pivot {
##################################################################################################
  my %args = @_;
  my $matrix = $args{matrix} || die ("ERROR: matrix not passed");

  # If matrix isn't an array, report error and return unsorted  
  if ( ref( $matrix  ) ne 'ARRAY' ) {
    print STDERR "Error: Matrix not arrayref in pivot\n";
    return { matrix => $matrix };
  } elsif ( !defined $matrix->[0] || ref( $matrix->[0] ne 'ARRAY' ) ) {
    print STDERR "Error: Matrix has too few elements in pivot\n";
    return { matrix => $matrix };
  }

  my $nRows = scalar(@{$matrix});
  my $nCols = scalar(@{$matrix->[0]});

  my @pivot;
  foreach my $iCol ( 0..($nCols-1) ) {
    my @newRow;
    foreach my $iRow ( 0..($nRows-1) ) {
      push(@newRow,$matrix->[$iRow]->[$iCol]);
    }
    push(@pivot,\@newRow);
  }

  my $response;
  $response->{matrix} = \@pivot;

  return $response;
}


sub cluster {
##################################################################################################
  my %args = @_;
  my $matrix = $args{matrix} || die ("ERROR: matrix not passed");

  my @pairwiseComparisons;
  my $nRows = scalar(@{$matrix});

  #### Calculate a variance for all pairs
  foreach my $iRow ( 0..(scalar(@{$matrix})-2) ) {
    foreach my $jRow ( ($iRow+1)..(scalar(@{$matrix}-1) ) ) {
      my $nElements = scalar(@{$matrix->[$iRow]});
      my $varianceSum = 0;
      foreach my $i ( 0..($nElements-1) ) {
	my $iValue = $matrix->[$iRow]->[$i];
	$iValue = -0.0002 if ( !defined($iValue) );
	my $jValue = $matrix->[$jRow]->[$i];
	$jValue = -0.0001 if ( !defined($jValue) );
	$varianceSum += abs( $iValue - $jValue );
      }
      push( @pairwiseComparisons, { variance=>$varianceSum, iRow=>$iRow, jRow=>$jRow } );
    }
  }

  #### Sort all the variances from smallest to largest
  my @sortedPairwiseComparisons = sort byVariance @pairwiseComparisons;

  my @clusteredArray;
  my @clusteredOrder;

  my $nRowsPlaced = 0;
  my %placedRows;
  my $lastRow;

  #### Loop through and determine a good ordered for all rows
  while ( $nRowsPlaced < $nRows ) {

    #### For the very first row, use the two closest together
    if ( !defined($lastRow ) ) {
      my $iRow = $sortedPairwiseComparisons[0]->{iRow};
      my $jRow = $sortedPairwiseComparisons[0]->{jRow};
      #print " ** $iRow\t$jRow\t$sortedPairwiseComparisons[0]->{variance}\n";
      push(@clusteredArray,$matrix->[$iRow],$matrix->[$jRow]);
      push(@clusteredOrder,$iRow,$jRow);
      $lastRow = $jRow;
      $placedRows{$iRow} = 1;
      $placedRows{$jRow} = 1;
      $nRowsPlaced += 2;

    #### For all the rest, find the next closest to what was placed
    } else {

      #### First shrink the array by removing things from the front that have been placed
      while ( $placedRows{$sortedPairwiseComparisons[0]->{iRow}} && $placedRows{$sortedPairwiseComparisons[0]->{jRow}} ) {
	#print "   - shift off $sortedPairwiseComparisons[0]->{iRow},$sortedPairwiseComparisons[0]->{jRow}\n";
	shift(@sortedPairwiseComparisons);
      }

      #### Then loop over the remaining to find the first best next thing to place
      foreach my $comparison ( @sortedPairwiseComparisons ) {
	my $iRow = $comparison->{iRow};
	my $jRow = $comparison->{jRow};
	next if ( $placedRows{$iRow} && $placedRows{$jRow});

	#### If the first of the pair matches the last row placed
	if ( $iRow == $lastRow ) {
	  push(@clusteredArray,$matrix->[$jRow]);
	  push(@clusteredOrder,$jRow);
	  $placedRows{$jRow} = 1;
	  $lastRow = $jRow;
	  #print " ** $iRow\t$jRow\t$comparison->{variance}\n";
	  $nRowsPlaced++;
	  last;

	#### Or if the second of the pair matches the last row placed
	} elsif ( $jRow == $lastRow ) {
	  push(@clusteredArray,$matrix->[$iRow]);
	  push(@clusteredOrder,$iRow);
	  $placedRows{$iRow} = 1;
	  $lastRow = $iRow;
	  #print " ** $iRow\t$jRow\t$comparison->{variance}\n";
	  $nRowsPlaced++;
	  last;
	}
      }
    }
  }

  my $result;
  $result->{clusteredArray} = \@clusteredArray;
  $result->{clusteredOrder} = \@clusteredOrder;
  return $result;
}

sub byVariance {
##################################################################################################
  return $a->{variance} <=> $b->{variance};
}

1;
