package BDQC::DataModel::Scalar;

###############################################################################
# Class       : BDQC::DataModel::Scalar
#
# Description : This class is autogenerated via generatePerlClasses.pl and
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::DataModel::Scalar';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';

#### BEGIN CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE




#### END CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Process constructor object parameters
  my $vector = processParameters( name=>'vector', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_vector} = $vector;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.




  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub getVector {
###############################################################################
# getVector
###############################################################################
  my $METHOD = 'getVector';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_vector});
}


sub setVector {
###############################################################################
# setVector
###############################################################################
  my $METHOD = 'setVector';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_vector} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub create {
###############################################################################
# create
###############################################################################
  my $METHOD = 'create';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $vector = processParameters( name=>'vector', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($vector) ) {
    $vector = $self->getVector();
  } else {
    $self->setVector($vector);
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.




  $isImplemented = 1;

  ## Need some better sanity checking here?

  my $nElements = 0;
  my %typeCounts = ( undefined=>0, empty=>0, integer=>0, float=>0, boolean=>0, string=>0 );
  my $stats = { sum=>0, mean=>0, nonNullElements=>0, minimum=>undef, maximum=>undef, median=>0, siqr=>0 };
  my %observedValues = ();

  #### Scan through the vector compiling the number of each type of value
  my @deviations = ();
  my @cleanedVector = ();
  foreach my $datum ( @{$vector} ) {
    $nElements++;
    my $dataType = '?';
    if ( ! defined($datum) ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*NaN\s*$/ ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*\-*Inf\s*$/ ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*null\s*$/i ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*undef\s*$/ ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*None\s*$/ ) { $dataType = 'undefined'; }
    elsif ( $datum =~ /^\s*$/ ) { $dataType = 'empty'; }
    elsif ( $datum =~ /^\s*[\+\-]*\d+\s*$/ ) { $dataType = 'integer'; }
    elsif ( $datum =~ /^\s*[\+\-]*\d+\.[\d]*\s*$/ ) { $dataType = 'float'; }
    elsif ( $datum =~ /^\s*[\+\-]*\.[\d]+\s*$/ ) { $dataType = 'float'; }
    elsif ( $datum =~ /^\s*[\+\-]*\d+\.[\d]*[ed][\+\-]*\d+\s*$/ ) { $dataType = 'float'; }
    elsif ( $datum =~ /^\s*[\+\-]*\.[\d]+[ed][\+\-]*\d+\s*$/ ) { $dataType = 'float'; }
    elsif ( $datum =~ /^\s*true\s*$/i || $datum =~ /^\s*false\s*$/i || $datum =~ /^\s*t\s*$/i || $datum =~ /^\s*f\s*$/i ) { $dataType = 'boolean'; }
    else { $dataType = 'string'; }
    $typeCounts{$dataType}++;
    push(@deviations,{ dataType=>$dataType, datum=>$datum, value=>$datum });
    if ( $dataType ne 'undefined' ) {
      push(@cleanedVector,$datum);
    }

    #### Add to the hash of all the observed values, although undef becomes null
    my $datumOrNull = $datum;
    $datumOrNull = 'null' if ( ! defined($datum) );
    $observedValues{$datumOrNull}++;

    #### Keep some stats to calculate a mean and standard deviation
    if ( $dataType eq 'integer' || $dataType eq 'float' ) {
      $stats->{sum} += $datum;
      $stats->{nonNullElements}++;
      if ( ! defined($stats->{minimum}) ) {
        $stats->{minimum} = $datum;
        $stats->{maximum} = $datum;
      } else {
        $stats->{minimum} = $datum if ( $datum < $stats->{minimum} );
        $stats->{maximum} = $datum if ( $datum > $stats->{maximum} );
      }
    }

  } # end foreach $datum


  #### Caclulate the mean
  if ( $stats->{nonNullElements} ) {
    $stats->{mean} = $stats->{sum} / $stats->{nonNullElements};
  }

  #### Try to decide the most likely dataType based on simple heuristics, allowing for missing values
  my $dataType = 'unknown';
  if ( $typeCounts{undefined} + $typeCounts{empty} + $typeCounts{integer} == $nElements ) {
    $dataType = 'integer';
  } elsif ( $typeCounts{undefined} + $typeCounts{empty} + $typeCounts{integer} + $typeCounts{float} == $nElements ) {
    $dataType = 'float';
  } elsif ( $typeCounts{undefined} + $typeCounts{empty} + $typeCounts{boolean} == $nElements ) {
    $dataType = 'boolean';
  } else {
    $dataType = 'string';
  }

  #### Probably need some special code to handle with there are less than ~5 values. FIXME
  # FIXME

  #### Determine a few classes of basic distributions (like allIdentical, TwoValued, allDifferent)
  my $nObservedValues = scalar(keys(%observedValues));
  my $distributionFlags = { allIdentical=>0, twoValued=>0, allDifferent=>0 };
  if ( $nObservedValues == 1 ) {
    $distributionFlags->{allIdentical} = 1;
  } elsif ( $nObservedValues == 2 ) {
    $distributionFlags->{twoValued} = 1;
  } elsif ( $nObservedValues == $nElements ) {
    $distributionFlags->{allDifferent} = 1;
  }

  #### If all the values are the same, then there's no point calculating stuff
  if ( $distributionFlags->{allIdentical} ) {
    if ( $dataType eq 'string' or $dataType eq 'boolean' ) {
      $stats->{median} = 0;
    } else {
      $stats->{median} = $vector->[0];
    }
   
  #### But if there is variation, then assess it
  } else {

    #### If this is a numerical vector, then calculate median and siqr
    if ( $dataType eq 'integer' or $dataType eq 'float' ) {
      my @sortedVector = sort numerically @cleanedVector;
      $stats->{median} = $sortedVector[$nElements/2];
      $stats->{siqr} = ( ( $sortedVector[$nElements/4*3] - $sortedVector[$nElements/4] ) / 2 );
      #print "Input: ".join(",",@sortedVector)."\n";
      my @sortedVectorSomeOutliersRemoved = removeSomeOutliers(@sortedVector);
      #print "Output: ".join(",",@sortedVectorSomeOutliersRemoved)."\n";
      my $sum = 0;
      foreach my $value ( @sortedVectorSomeOutliersRemoved ) {
        $sum += $value;
      }
      my $newNElements = scalar(@sortedVectorSomeOutliersRemoved) || 1;
      $stats->{adjustedMean} = $sum/$newNElements;
      $sum = 0;
      foreach my $value ( @sortedVectorSomeOutliersRemoved ) {
        $sum += ($value-$stats->{adjustedMean})**2;
      }
      $stats->{adjustedStdev} = sqrt($sum/$newNElements);
    }

    #### If this is a string vector, then first turn each string into a number based on the characters
    ####   it contains and its length, and then calculate median and siqr
    if ( $dataType eq 'string' ) {
      my @numericalVector;
      my $iValue = 0;
      foreach my $datum ( @{$vector} ) {
        my $asciiAverage = 0;
        for (my $i=0; $i<length($datum); $i++) {
          $asciiAverage += ord(substr($datum,$i,1));
        }
        my $datumLength = length($datum) || 1;
        $asciiAverage /= $datumLength;
        my $stringValue = length($datum)+$asciiAverage;
        push(@numericalVector,$stringValue);
        $deviations[$iValue]->{stringValue} = $stringValue;

        #### Keep some stats to calculate a mean and standard deviation
        my $datum = $stringValue;
        $stats->{sum} += $datum;
        $stats->{nonNullElements}++;
        if ( ! defined($stats->{minimum}) ) {
          $stats->{minimum} = $datum;
          $stats->{maximum} = $datum;
        } else {
          $stats->{minimum} = $datum if ( $datum < $stats->{minimum} );
          $stats->{maximum} = $datum if ( $datum > $stats->{maximum} );
        }

        $iValue++;
      }
      my @sortedVector = sort numerically @numericalVector;
      $stats->{median} = $sortedVector[$nElements/2];
      $stats->{siqr} = ( ( $sortedVector[$nElements/4*3] - $sortedVector[$nElements/4] ) / 2 );

      #### Calculate the mean
      if ( $stats->{nonNullElements} ) {
        $stats->{mean} = $stats->{sum} / $stats->{nonNullElements};
      }

    }

    #### Calculate the extremities at 3 times SIQR and outliers at 5 times SIQR
    my $iValue = 0;
    $stats->{variance} = 0;
    my $siqr = $stats->{siqr} || $stats->{stdev} || $stats->{mean}/10 || 1;
    foreach my $datum ( @{$vector} ) {
      my $value = $datum;
      if ( $dataType eq 'string' ) {
        $value = $deviations[$iValue]->{stringValue};
      }

      #### If the value is not null, then add to the variance
      if ( defined($value) && defined($stats->{mean}) ) {
        $stats->{variance} += ( ($value - $stats->{mean})**2 );
      }

      #### If the value is undefined, can't really calculate a deviation. Set to 999
      my $deviation = 999;
      if ( defined($value) && defined($siqr) ) {

        #### Now try calculating the deviation based on a mean and stdev after some crude extreme value removal if available
        if ( defined($stats->{adjustedMean}) && $stats->{adjustedStdev} ) {
          $deviation = abs($stats->{adjustedMean}-$value)/$stats->{adjustedStdev};

        #### Else fall back to the original crude mechanism
        } else {
          #### First attempt based simply on the median and the SIQR. Crude.
          $deviation = abs($stats->{median}-$value)/$siqr;
        }
      }

      $deviations[$iValue]->{deviation} = $deviation;
      my $flag = 'normal';
      $flag = 'extremity' if ( $deviation >= 3 );
      $flag = 'outlier' if ( $deviation >= 5 );

      #### Protect against undefined values
      my $datumOrNull = $datum;
      $datumOrNull = 'null' if ( !defined($datum) );

      #### Or if this is a two-valued distribution with only 1 or 2 outliers, then mark as an outlier
      #### Somewhat specialized, arbitrary rules
      if ( $distributionFlags->{twoValued} ) {
        if ( $observedValues{$datumOrNull} == 1 ) {
          $flag = 'extremity' if ( $nElements > 2 );
          $flag = 'outlier' if ( $nElements > 4 );
        } elsif ( $observedValues{$datumOrNull} == 2 ) {
          $flag = 'extremity' if ( $nElements > 5 );
          $flag = 'outlier' if ( $nElements > 9 );
        }
      }
        
      $deviations[$iValue]->{deviationFlag} = $flag;
      $deviations[$iValue]->{value} = $value;
      $iValue++;
    }    

    #### Calculate the stdev
    if ( defined($stats->{variance}) && defined($stats->{nonNullElements}) ) {
      $stats->{stdev} = sqrt( $stats->{variance}/$stats->{nonNullElements} );
    }

  } # end else (not allIdentical)


  #### Store the information gleaned into the model in the response
  $response->{model} = { dataType=>$dataType, typeCounts=>\%typeCounts, observedValues=>\%observedValues,
    distributionFlags=>$distributionFlags, stats=>$stats, deviations=>\@deviations };





  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub show {
###############################################################################
# show
###############################################################################
  my $METHOD = 'show';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Create a simple text representation of the data in the object
  my $buffer = '';
  $buffer .= "$self\n";
  my $vector = $self->getVector() || '';
  $buffer .= "  vector=$vector\n";

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $buffer;
}


sub numerically {
###############################################################################
# numerically
# sorting routine to sort numbers but allow for missing values, which sort first
###############################################################################
  if ( ( (! defined($a)) || $a =~ /^\s*$/) && ( (! defined($b)) || $b =~ /^\s*$/) ) {
    return 0;
  } elsif ( (! defined($a)) || $a =~ /^\s*$/ ) {
    return -1;
  } elsif ( ! defined($b) || $b =~ /^\s*$/ ) {
    return 1;
  }
  return $a <=> $b;
}


sub removeSomeOutliers {
###############################################################################
# removeSomeOutliers
# Gets as input a sorted numerical vector with nulls removed
# Trims a reasonable number from the ends if they seem extreme
###############################################################################
  my @cleanedSortedVector = @_;

  my @deltas;
  my $nElements = scalar(@cleanedSortedVector);

  #### If there aren't even 3 datapoints, just return what came in
  if ( $nElements < 3 ) {
    return(@cleanedSortedVector);
  }

  #### Calculate the deltas of all the data points
  for (my $i=0; $i<$nElements-1; $i++) {
    push(@deltas,$cleanedSortedVector[$i+1]-$cleanedSortedVector[$i]);
  }

  #### Find the median of the deltas
  my @sortedDeltas = sort numerically @deltas;
  my $medianDelta = $sortedDeltas[$nElements/2-1];

  #### Set a reasonable number of points to potentially reject
  my $nPointsToReject = 1;
  $nPointsToReject = 2 if ( $nElements >= 5 );
  $nPointsToReject = 3 if ( $nElements >= 8 );
  $nPointsToReject = 4 if ( $nElements >= 12 );
  $nPointsToReject = 5 if ( $nElements >= 20 );
  $nPointsToReject = 6 if ( $nElements >= 30 );
  $nPointsToReject = $nElements*0.15 if ( $nElements >= 50 );
  $nPointsToReject = $nElements*0.05+10 if ( $nElements >= 100 );

  #### Loop through the sorted vector discarding either the first or last, whichever is farther
  #### This should be better FIXME
  while ( $nPointsToReject > 0 ) {
    my $nElementsLeft = scalar(@cleanedSortedVector);
    my $i=0;
    my $lowerDelta = $cleanedSortedVector[$i+1]-$cleanedSortedVector[$i];
    $i=$nElementsLeft-2;
    my $upperDelta = $cleanedSortedVector[$i+1]-$cleanedSortedVector[$i];

    if ( $lowerDelta > $upperDelta ) {
      shift(@cleanedSortedVector);
    } else {
      pop(@cleanedSortedVector);
    }
    $nPointsToReject--;
  }

  return @cleanedSortedVector;  
}


###############################################################################
1;
