package BDQC::KB;

###############################################################################
# Class       : BDQC::KB
#
# Description : This class is autogenerated via generatePerlClasses.pl and
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::KB';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';

#### BEGIN CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE

use BDQC::DataModel;

#### END CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Process constructor object parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_dataDirectory} = $dataDirectory;
  my $isChanged = processParameters( name=>'isChanged', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_isChanged} = $isChanged;
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_kbRootPath} = $kbRootPath;
  my $qckb = processParameters( name=>'qckb', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_qckb} = $qckb;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub getDataDirectory {
###############################################################################
# getDataDirectory
###############################################################################
  my $METHOD = 'getDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_dataDirectory});
}


sub setDataDirectory {
###############################################################################
# setDataDirectory
###############################################################################
  my $METHOD = 'setDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_dataDirectory} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getIsChanged {
###############################################################################
# getIsChanged
###############################################################################
  my $METHOD = 'getIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_isChanged});
}


sub setIsChanged {
###############################################################################
# setIsChanged
###############################################################################
  my $METHOD = 'setIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;

  #### Ensure that the value is of type int32
  unless ( $value =~ /^s*[\-\+]*\d+\s*$/ ) {
    print "ERROR: Unable to set isChanged to '$value': not valid int32\n";
  }


  $self->{_isChanged} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getKbRootPath {
###############################################################################
# getKbRootPath
###############################################################################
  my $METHOD = 'getKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_kbRootPath});
}


sub setKbRootPath {
###############################################################################
# setKbRootPath
###############################################################################
  my $METHOD = 'setKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_kbRootPath} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getQckb {
###############################################################################
# getQckb
###############################################################################
  my $METHOD = 'getQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_qckb});
}


sub setQckb {
###############################################################################
# setQckb
###############################################################################
  my $METHOD = 'setQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_qckb} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub calcModels {
###############################################################################
# calcModels
###############################################################################
  my $METHOD = 'calcModels';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating models for all available signatures");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### If the user specified some attributes to skip, create a hash of them
  my %attributesToSkip = ();
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  #### For each fileType, signature, and attribute, build a model of the observed data
  my $nOperations = 0;
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {
        next if ( $attributesToSkip{"$signature.$attribute"} );
        my $values = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{values};
        my $model;
        $model = BDQC::DataModel->new( vector=>$values );
        my $result = $model->create();
        $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model} = $result->{model};
        $response->mergeResponse( sourceResponse=>$result );
        $nOperations++;
      }
    }
  }

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Calculate models of what seems normal for all $nOperations attributes of all signatures"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub calcSignatures {
###############################################################################
# calcSignatures
###############################################################################
  my $METHOD = 'calcSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating signatures for all new files");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  use BDQC::FileSignature::Text;
  use BDQC::FileSignature::Binary;
  use BDQC::FileSignature::XML;
  use BDQC::FileSignature::Tabular;
  use Time::HiRes qw(gettimeofday tv_interval);

  my %knownExtensions = (
    "tsv" => { specificTypeName=>'tsv', genericType=>'tabular', signatureList=>[ "FileSignature::Tabular" ] },
    "fasta" => { specificTypeName=>'FASTA', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "qlog" => { specificTypeName=>'qlog', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "txt" => { specificTypeName=>'txt', genericType=>'txt', signatureList=>[ "FileSignature::Text" ] },
    "xml" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "mzML" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "jpg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "jpeg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPEG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "raw" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
    "RAW" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
  );

  eval {
    require XML::Parser;
  };
  if ( $@ ) {
    print STDERR "XML::Parser not found, reverting to TXT analysis only\n";
    $knownExtensions{xml}->{signatureList} = [ "FileSignature::Text" ];
    $knownExtensions{mzML}->{signatureList} = [ "FileSignature::Text" ];
  }

  my $nFiles = 0;

  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $filePath = $signatures->{tracking}->{filePath};
    if ( $signatures->{extrinsic}->{isCompressed} ) {
      $filePath = "zcat $filePath |";   #FIXME
    }
    my $knownExtension = $knownExtensions{$signatures->{extrinsic}->{uncompressedExtension}};
    my @signatureList;
    my $fileTypeName = $signatures->{extrinsic}->{uncompressedExtension};
    if ( $knownExtension ) {
      @signatureList = @{$knownExtension->{signatureList}};
      $fileTypeName = $knownExtension->{specificTypeName};
    } else {
      #$signatureList = [ 'FileSignature::UnknownFiletype' ];
      @signatureList = ( 'FileSignature::Text' );
    }
    $signatures->{fileType}->{typeName} = $fileTypeName;

    #### Determine if there is some custom signatures that apply here, and update the signatureList
    if ( $qckb->{pluginSignatures} ) {
      foreach my $testFileTypeName ( ( "*all",$fileTypeName) ) {
        if ( $qckb->{pluginSignatures}->{$testFileTypeName} ) {
          #print "yes, there's a $testFileTypeName\n";
          if ( $qckb->{pluginSignatures}->{$testFileTypeName}->{set} ) {
            @signatureList = @{$qckb->{pluginSignatures}->{$testFileTypeName}->{set}};
          }
          if ( $qckb->{pluginSignatures}->{$testFileTypeName}->{add} ) {
            push(@signatureList, @{$qckb->{pluginSignatures}->{$testFileTypeName}->{add}});
            #print "  yes, there's an add for that. Now: ".join(",",@signatureList)."\n";
          }
        }
      }
    }

    #### Loop over each signature to process and add the results
    foreach my $signatureName ( @signatureList ) {
      my $moduleName = "BDQC::$signatureName";
      my $result;
      if ( $signatureName =~ /^FileSignature::/ ) {
        #print "Running $moduleName\n";
        my $signature = $moduleName->new( filePath=>$filePath );
        #my $t0 = [gettimeofday];
        $result = $signature->calcSignature();
        #my $t1 = [gettimeofday];
        #my $elapsed = tv_interval($t0,$t1);
        #print "$fileTag  $elapsed\n";
      } else {
        my @resultText = `$signatureName --filename $filePath`;
        $result = decode_json(join("\n",@resultText));
        if ( $result->{signatureName} ) {
          $signatureName = $result->{signatureName};
        }
      }

      if ( $result->{status} eq 'OK' ) {
        $signatures->{$signatureName} = $result->{signature};
      } else {
        $response->mergeResponse( sourceResponse=>$result );
        return $response;
      }
    }

  }

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Calculated signatures for $nFiles files", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Calculate signatures for $nFiles files"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub collateData {
###############################################################################
# collateData
###############################################################################
  my $METHOD = 'collateData';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Collating all data from signatures into a matrix");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  my $nFiles = 0;
  my $allAttributes;

  #### Create a list of attributes that should not be collated, mostly because they're not useful or redundant
  my %attributesToSkip = (
    "fileType"=>1,
    "extrinsic.uncompressedExtension"=>1,
    "extrinsic.basename"=>1,
    "extrinsic.extension"=>1,
    "tracking.isNew"=>1,
    "tracking.fileTag"=>1,
    "tracking.dataDirectoryId"=>1,
    "tracking.filePath"=>1,
    "tracking.filename"=>1,
  );

  #### If the user specified some attributes to skip, add those
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  
  #### First scan through all the files and assign them to a fileType. Models will be built within fileTypes
  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {

    #### Get the signatures for this file and the fileTypeName (commonly a file extention)
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $fileTypeName = $signatures->{fileType}->{typeName};

    #### If this fileTypeName has not yet been added, do so
    unless ( $qckb->{fileTypes}->{$fileTypeName} ) {
      $qckb->{fileTypes}->{$fileTypeName} = { name=>$fileTypeName, fileTagList=>[], signatures=>{} };
    }

    #### If this is a new file, then add it to the file of files for this filetype
    if ( $signatures->{tracking}->{isNew} ) {
      push(@{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}},$fileTag);

      #### Also create a complete hash of all attributes for each signature
      foreach my $signature ( keys(%{$signatures}) ) {
        foreach my $attribute ( keys(%{$signatures->{$signature}}) ) {

          #### Check to see if this signature/attribute is one we should skip, or else add it to the list
          if ( $attributesToSkip{$signature} ) {
            #print "Don't bother collating all of signature $signature\n";
          } elsif ( $attributesToSkip{"$signature.$attribute"} ) {
            #print "Don't bother collating $signature.$attribute\n";
          } else {
            $allAttributes->{fileTypes}->{$fileTypeName}->{signatures}->{$signature}->{attributes}->{$attribute}++;
          }
        }
      }
    }
    $nFiles++;
  }

  #### For each fileType, extract all the signatures for which we'll make a model
  foreach my $fileTypeName ( keys(%{$qckb->{fileTypes}}) ) {
    my $signatures = $qckb->{fileTypes}->{$fileTypeName}->{signatures};
    foreach my $fileTag ( @{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}} ) {
      foreach my $signature ( keys(%{$qckb->{files}->{$fileTag}->{signatures}}) ) {

        #### Loop over the complete list of all attributes we collected for this signature
        foreach my $attribute ( keys(%{$allAttributes->{fileTypes}->{$fileTypeName}->{signatures}->{$signature}->{attributes}}) ) {

          #### If we haven't encountered this attribute yet, then create an empty array
          unless ( $signatures->{$signature}->{$attribute}->{values} ) {
            $signatures->{$signature}->{$attribute}->{values} = [];
          }

          #### The fileAttribute starts as undef
          my $fileAttribute;
          #### See if it even exists for this file (it might not). If so, extract it
          if ( exists($qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute}) ) {
            $fileAttribute = $qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute};
          }
          #### Push whatever we found or didn't find onto the list. This list might have some nulls
          push(@{$signatures->{$signature}->{$attribute}->{values}},$fileAttribute);
        }
      }
    }
  }

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Collated all the signatures from all files into a matrix for analysis"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub createKb {
###############################################################################
# createKb
###############################################################################
  my $METHOD = 'createKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>1, message=>"Creating new BDQC KB for storing results", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create the qckb data structure and fill it with basic information
  my $qckb = {};
  $self->setQckb($qckb);
  $qckb->{kBtype} = "BDQC";
  $self->setIsChanged(1);

  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  $qckb->{startDate} = sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec);

  #### Empty array for updates
  $qckb->{updates} = [];
  $qckb->{dataDirectories} = [];

  $qckb->{files} = {};
  $qckb->{fileTypes} = {};

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub getOutliers {
###############################################################################
# getOutliers
###############################################################################
  my $METHOD = 'getOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Listing outliers in the BDQC KB");

  my $qckb = $self->getQckb();
  my $outliers;
  my $nOutlierFiles;

  #### If the user specified some attributes to skip, create a hash of them
  my %attributesToSkip = ();
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  #### For each fileType, signature, and attribute, record if any deviations are outliers
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    $outliers->{fileTypes}->{$fileType}->{nFiles} = 0;

    #### First, get the list of fileTagNames for this fileType
    my $fileTagNames = $qckb->{fileTypes}->{$fileType}->{fileTagList};

    #### Loop over the signatures and attributes
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {

        #### Skip this one if requested
        next if ( $attributesToSkip{"$signature.$attribute"} );

        #print "$signature.$attribute:\n";
        my $model = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model};

        #### Loop over all the deviations, looking for one labeled an outlier
        my $iDeviation = 0;
        foreach my $deviation ( @{$model->{deviations}} ) {
          if ( defined($deviation->{deviationFlag}) && $deviation->{deviationFlag} eq 'outlier' ) {

            #### Extract the datum and vaue for the outlier and condition a bit
            my $value = '(null)';
            my $datum = '(null)';
            $value = $deviation->{value} if ( defined($deviation->{value}) );
            $datum = $deviation->{datum} if ( defined($deviation->{datum}) );
            my $tmpText = "'$datum'";
            $tmpText .= " (with value $value)" if ( $datum ne $value );
            #print "  Datum $tmpText is an outlier with a deviation of '$deviation->{deviation}'\n";

            #### Store the information about this outlier
            my $fileTagName = $fileTagNames->[$iDeviation];
            my $outlierData = { signature=>$signature, attribute=>$attribute, datum=>$datum, value=>$value, deviation=>$deviation };
            push( @{$outliers->{fileTypes}->{$fileType}->{fileTags}->{$fileTagName}}, $outlierData );
            $outliers->{fileTypes}->{$fileType}->{nFiles}++;
          }
          $iDeviation++;
        } # end foreach deviation

      } # end foreach attribute

    } # end foreach signature

  } # end foreach fileType


  #### Print out the outlier files and their outlier values
  foreach my $fileType ( sort keys(%{$outliers->{fileTypes}}) ) {
    foreach my $outlierFileTagName ( sort keys(%{$outliers->{fileTypes}->{$fileType}->{fileTags}}) ) {
      print "$outlierFileTagName is an outlier because:\n";
      $nOutlierFiles++;
      my $outlierFileTagList = $outliers->{fileTypes}->{$fileType}->{fileTags}->{$outlierFileTagName};
      foreach my $outlier ( @{$outlierFileTagList} ) {
        my $signature = $outlier->{signature};
        my $attribute = $outlier->{attribute};
        my $value = $outlier->{value};
        my $deviation = $outlier->{deviation}->{deviation};
        $value = '(null)' if ( ! defined($value) );
        $value = substr($value,0,70)."...." if ( length($value)>74 );
        print "  $signature.$attribute: Value '$value' is an outlier at $deviation times typical deviation\n";
      }
    }
  }

  #### If there were none, print that
  unless ( $nOutlierFiles ) {
    print " - No outliers found\n";
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub importSignatures {
###############################################################################
# importSignatures
###############################################################################
  my $METHOD = 'importSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $importLimit = processParameters( name=>'importLimit', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $inputFile = processParameters( name=>'inputFile', required=>1, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### If the file exists, read it
  if ( -e $inputFile ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Importing BDQC data into KB from '$inputFile'");
    my $qckb =  $self->getQckb();

    if ( $inputFile =~ /\.gz$/ ) {
      $inputFile = "zcat $inputFile |";
    }

    if ( open(INFILE,$inputFile) ) {
      my $jsonData = '';
      while ( my $line = <INFILE> ) {
        $jsonData .= $line;
      }
      close(INFILE);
      my $inputBdqc = decode_json($jsonData);
      my $iFile = 0;
      foreach my $file ( keys(%{$inputBdqc}) ) {
        my $tmp = {};
        my $components = $self->splitFilePath($file);
        my $fileTag = "import1:$file";
        my $tracking = { fileTag=>$fileTag, filePath=>$file, filename=>$components->{filename},
          dataDirectory=>$components->{directory}, dataDirectoryId=>'import1', isNew=>1 };
        $tmp->{tracking} = $tracking;

        $tmp->{extrinsic}->{mtime} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{mtime};
        $tmp->{extrinsic}->{size} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{size};
        $tmp->{extrinsic}->{extension} = $components->{extension};
        $tmp->{extrinsic}->{uncompressedExtension} = $components->{uncompressedExtension};
        $tmp->{extrinsic}->{isCompressed} = $components->{isCompressed};
        $tmp->{extrinsic}->{filename} = $components->{filename};
        $tmp->{extrinsic}->{basename} = $components->{basename};
        $tmp->{extrinsic}->{readable} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{readable};
        $tmp->{fileType}->{typeName} = $components->{uncompressedExtension};

        #### Loop over all the other signatures and import them
        foreach my $signatureName ( keys(%{$inputBdqc->{$file}}) ) {
          #### Skip the ones that we've already translated by hand
          next if ( $signatureName eq 'bdqc.builtin.extrinsic' );
          next if ( $signatureName eq 'bdqc.builtin.filetype' );
          #### Loop over each attribute or container
          foreach my $attributeName ( keys(%{$inputBdqc->{$file}->{$signatureName}}) ) {
            my $attributeValue = $inputBdqc->{$file}->{$signatureName}->{$attributeName};

            #### If this attribute is already a scalar, then just store it
            if ( ref($attributeValue) eq '' ) {
              $tmp->{$signatureName}->{$attributeName} = $attributeValue;
              #print "Storing at base $signatureName.$attributeName = $attributeValue\n";
            #### Else if it complex, flatten it recursively into keys and values that are scalar, hash, or array
            } else {
              #print "Going complex!\n";
              my $flattenedAttributes = flattenAttributes($attributeName,$attributeValue);
              foreach my $flattenendAttributeName ( keys(%{$flattenedAttributes}) ) {
                #print "  Adding $signatureName.$flattenendAttributeName = $flattenedAttributes->{$flattenendAttributeName}\n";
                $tmp->{$signatureName}->{$flattenendAttributeName} = $flattenedAttributes->{$flattenendAttributeName};
              }
            }
              
          } # end foreach attributeName
        } # end foreach signatureName


        #delete($tmp->{signatures}->{"bdqc.builtin.tabular"});
        $qckb->{files}->{$fileTag}->{signatures} = $tmp;
        $iFile++;

        #### End early if requested
        if ( $importLimit ) {
          if ( $iFile >= $importLimit ) {
            $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
              message=>"Importing ended after $importLimit records as requested");
            last;
          }
        }
      }

      $self->setIsChanged(1);

      #### Create an entry in the updates log about what this did
      my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
      my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
        operation => $METHOD,
        comment => "Imported signatures from external file '$inputFile'"
      };
      push(@{$qckb->{updates}},$updateEntry);

    } else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileCannotBeOpened", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Input file '$inputFile' exists but cannot be opened.");
    }
    
  } else {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Input file '$inputFile' does not exist.");
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub loadKb {
###############################################################################
# loadKb
###############################################################################
  my $METHOD = 'loadKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $skipIfFileNotFound = processParameters( name=>'skipIfFileNotFound', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  $kbRootPath = $self->getKbRootPath();
  my $filename = "$kbRootPath.qckb.storable";

  #### Make sure the file exists
  if ( -e $filename ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Loading BDQC KB from '$filename'");
    my $qckb =  retrieve($filename);
    $self->setQckb($qckb);
    $self->setIsChanged(0);

  } else {
    if ( $skipIfFileNotFound ) {
      $response->setState( status=>'OK', message=>"Skipping IfFileNotFound as requested");
      $response->{fileNotFound} = 1;
    } else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"DatastoreDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Datastore '$filename' does not exist.");
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub parsePlugins {
###############################################################################
# parsePlugins
###############################################################################
  my $METHOD = 'parsePlugins';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $pluginModels = processParameters( name=>'pluginModels', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $pluginSignatures = processParameters( name=>'pluginSignatures', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();

  #### Plugin models are not yet supported
  if ( $pluginModels ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'pluginModelsNotYetSupported', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Although the option is listed, the option pluginModels is not yet written. Coming soon..");
    return $response;
  }

  #### Parse the pluginSignatures and if okay store in the KB
  if ( $pluginSignatures ) {
    my @commands = split(/;/,$pluginSignatures);
    foreach my $command ( @commands ) {
      my ($condition,$executable) = split(/=/,$command);
      if ( $condition && $executable ) {
        my ($fileType,$mode) = split(/:/,$condition);
        if ( $fileType && $mode ) {
          if ( -e $executable ) {
            push( @{$qckb->{pluginSignatures}->{$fileType}->{$mode}}, $executable);
          } else {
           $response->logEvent( level=>'WARNING', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
            message=>"Specified external plugin executable '$executable' does not exist as a single file, although might be a compound command");
            push( @{$qckb->{pluginSignatures}->{$fileType}->{$mode}}, $executable);
         }
        } else {
          $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'PluginSignatureMIssingColon', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
            message=>"Each pluginSignatures must have an = in it in the form condition=executable");
       }

      } else {
        $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'PluginSignatureMissingEqualSign', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
          message=>"Each pluginSignatures must have an = in it in the form condition=executable");
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub saveKb {
###############################################################################
# saveKb
###############################################################################
  my $METHOD = 'saveKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  my $qckb = $self->getQckb();
  $kbRootPath = $self->getKbRootPath();

  unless ( $self->getIsChanged() ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB has not changed. No need to save.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
    $response->setState( status=>'OK', message=>"No changes in the KB. No need to save.");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $filename = "$kbRootPath.qckb.storable";
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Saving BDQC KB to '$filename' and .json", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  store($qckb,$filename);
  $self->setIsChanged(0);

  use JSON;
  my $json = JSON->new->allow_nonref;
  $json->canonical();
  my $buffer = $json->pretty->encode($qckb);
  $filename = "$kbRootPath.qckb.json";
  open(OUTFILE,">$filename");
  print OUTFILE $buffer;
  close(OUTFILE);

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB saved", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub scanDataPath {
###############################################################################
# scanDataPath
###############################################################################
  my $METHOD = 'scanDataPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($dataDirectory) ) {
    $dataDirectory = $self->getDataDirectory();
  } else {
    $self->setDataDirectory($dataDirectory);
  }

  if ( ! defined($dataDirectory) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributedataDirectoryNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'dataDirectory' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### If the dataDirectory was a Windows path, fix it
  if ( $dataDirectory =~ /\\/ ) {
    $dataDirectory =~ s/\\/\//g;
    $self->setDataDirectory($dataDirectory);
  }

  my %stats = ( totalFiles=>0, newFiles=>0, totalSize=>0 );

  #### Verify that the specified directory exists and is a directory
  if ( ! -e $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'DataDirecoryNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is not found");
    return $response;
  } elsif ( ! -d $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'SpecifiedDataDirecoryNotADirectory', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is  found but is not a directory");
    return $response;
  }

  #### See if this dataDirectory has already been scanned
  my $dataDirectoryId = '';
  my $nPreviousDirectories = scalar(@{$qckb->{dataDirectories}});
  foreach my $previousDirectories ( @{$qckb->{dataDirectories}} ) {
    if ( $previousDirectories->{path} eq $dataDirectory ) {
      $dataDirectoryId = $previousDirectories->{id};
    }
  }

  #### If we haven't scanned this one before, add this path now
  unless ( $dataDirectoryId ) {
    $nPreviousDirectories++;
    $dataDirectoryId = "dir$nPreviousDirectories";
    push(@{$qckb->{dataDirectories}}, { id=>$dataDirectoryId, path=>$dataDirectory });
  }

  #### Put this directory on the stack and recursively catalog all files}
  my @directoriesToProcess = ( $dataDirectory );
  my $done = 0;
  while ( ! $done ) {
    my $directory = shift(@directoriesToProcess);
    last unless ( $directory );
    opendir(DIR,$directory) || die("ERROR: Unable to open directory '$directory'");
    my @entries = grep(!/^\.{1,2}$/, readdir(DIR));
    closedir(DIR);
    @entries = sort(@entries);
    foreach my $entry ( @entries ) {
      if ( -f "$directory/$entry" ) {
        my $fileTag = "$dataDirectoryId:$directory/$entry";
        my $filePath = "$directory/$entry";
        $stats{totalFiles}++;

        #### Parse the filename into pieces
        my @parts = split(/\./,$entry);
        my $nParts = scalar(@parts);
        my $basename = '';
        my $extension = '';
        my $uncompressedExtension = '';
        my $isCompressed = 0;
        if ( $nParts == 1) {
          $basename = $entry;
        } else {
          $extension = $parts[$nParts-1];
          my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
          if ( $compressedExtensions{$extension} ) {
            $isCompressed = 1;
            if ( $nParts == 2 ) {
              $basename = $parts[0];
            } else {
              $uncompressedExtension = $parts[$nParts-2];
              $basename = join(".",@parts[0..$nParts-3]);
            }
          } else {
            $uncompressedExtension = $extension;
            $basename = join(".",@parts[0..$nParts-2]);
          }
        }

        my $tracking = { fileTag=>$fileTag, filePath=>$filePath, filename=>$entry, dataDirectory=>$dataDirectory, dataDirectoryId=>$dataDirectoryId };
        my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($filePath);
        $size = 0 if ( ! defined($size) );
        $mtime = 0 if ( ! defined($mtime) );
        $mode = 0 if ( ! defined($mode) );
        $stats{totalSize} += $size;

        if ( exists($qckb->{files}->{$fileTag}) ) {
          $tracking->{isNew} = 0;
          $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isNew} = 0;
          if ( $mtime ne $qckb->{files}->{$fileTag}->{signatures}->{extrinsic}->{mtime} ) {
            $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isChanged} = 1;
          }
        } else {
          $tracking->{isNew} = 1;
          $stats{newFiles}++;
          $qckb->{files}->{$fileTag} ->{signatures}->{tracking} = $tracking;
          my $extrinsic = { filename=>$entry, mtime=>$mtime, size=>$size, mode=>$mode, extension=>$extension, iscompressed=>$isCompressed, uncompressedExtension=>$uncompressedExtension, basename=>$basename };
          $qckb->{files}->{$fileTag}->{signatures}->{extrinsic} = $extrinsic;
        }
      } elsif ( -d "$directory/$entry" ) {
        push(@directoriesToProcess,"$directory/$entry");
      } else {
        print "Do not know what to do with $directory/$entry\n";
      }
    }
  }

  $response->{stats} = \%stats;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"$stats{totalFiles} files ($stats{totalSize} bytes) scanned. $stats{newFiles} files are new to this scan.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Scanned data directory '$dataDirectory' and added $stats{newFiles} new files"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub show {
###############################################################################
# show
###############################################################################
  my $METHOD = 'show';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Create a simple text representation of the data in the object
  my $buffer = '';
  $buffer .= "$self\n";
  my $dataDirectory = $self->getDataDirectory() || '';
  $buffer .= "  dataDirectory=$dataDirectory\n";
  my $isChanged = $self->getIsChanged() || '';
  $buffer .= "  isChanged=$isChanged\n";
  my $kbRootPath = $self->getKbRootPath() || '';
  $buffer .= "  kbRootPath=$kbRootPath\n";
  my $qckb = $self->getQckb() || '';
  $buffer .= "  qckb=$qckb\n";

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $buffer;
}


sub flattenAttributes {
###############################################################################
# flattenAttributes
# Reduce the depth of attributes to the top level, except permit hashes and
# arrays of scalars
###############################################################################
  my ($attributeName,$attributeValue) = @_;

  my $result;

  #### If the passed attributeValue is just a scalar, then record it as is (probably should never happen?)
  if ( ref($attributeValue) eq '' || ref($attributeValue) eq 'JSON::PP::Boolean' ) {
    $result->{attributeName} = $attributeValue;

  #### Else if this is a HASH then process it
  } elsif ( ref($attributeValue) eq 'HASH' ) {

    #### First loop through to see if they're all scalars or not
    my $allAreScalars = 1;
    foreach my $key ( keys(%{$attributeValue}) ) {
      my $value = $attributeValue->{$key};
      if ( ref($value) ne '' && ref($value) ne 'JSON::PP::Boolean' ) {
        $allAreScalars = 0;
      }
    }
      
    #### If they're all scalars, then return this as a histogram as is
    if ( $allAreScalars ) {
      $result->{$attributeName} = $attributeValue;

    #### But if at least one is complex, then record the scalars as attributes and recurse into the complex ones
    } else {
      foreach my $key ( keys(%{$attributeValue}) ) {
        my $value = $attributeValue->{$key};
        if ( ref($value) eq '' || ref($value) eq 'JSON::PP::Boolean' ) {
          $result->{"$attributeName.$key"} = $value;
        } else {
          my $recursedResult = flattenAttributes("$attributeName.$key",$value);
          foreach my $recursedKey ( keys(%{$recursedResult}) ) {
            $result->{$recursedKey} = $recursedResult->{$recursedKey};
          }
        }
      }
    }

  #### Else if this is an ARRAY then process it
  } elsif ( ref($attributeValue) eq 'ARRAY' ) {

    #### First loop through to see if they're all scalars or not
    my $allAreScalars = 1;
    foreach my $value ( @{$attributeValue} ) {
      if ( ref($value) ne '' && ref($value) ne 'JSON::PP::Boolean' ) {
        $allAreScalars = 0;
      }
    }
      
    #### If they're all scalars, then return this as a histogram as is
    if ( $allAreScalars ) {
      $result->{$attributeName} = $attributeValue;

    #### But if at least one is complex, then record the scalars as attributes and recurse into the complex ones
    } else {
      my $i = 0;
      foreach my $value ( @{$attributeValue} ) {
        if ( ref($value) eq '' || ref($value) eq 'JSON::PP::Boolean' ) {
          $result->{"$attributeName.$i"} = $value;
        } else {
          my $recursedResult = flattenAttributes("$attributeName.$i",$value);
          foreach my $recursedKey ( keys(%{$recursedResult}) ) {
            $result->{$recursedKey} = $recursedResult->{$recursedKey};
          }
        }
        $i++;
      }
    }

  }
  
  return $result;
}
sub splitFilePath {
###############################################################################
# splitFilePath
###############################################################################
  my $METHOD = 'splitFilePath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my $filePath = shift;

  my %components;

  #### Parse off the directory
  my @pathParts = split(/\//,$filePath);
  my $directory = join("\/",@pathParts[0..($#pathParts-1)]);
  my $entry = $pathParts[$#pathParts];

  #### Parse the filename into pieces
  my @parts = split(/\./,$entry);
  my $nParts = scalar(@parts);
  my $basename = '';
  my $extension = '';
  my $uncompressedExtension = '';
  my $isCompressed = 0;
  if ( $nParts == 1) {
    $basename = $entry;
  } else {
    $extension = $parts[$nParts-1];
    my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
    if ( $compressedExtensions{$extension} ) {
      $isCompressed = 1;
      if ( $nParts == 2 ) {
        $basename = $parts[0];
      } else {
        $uncompressedExtension = $parts[$nParts-2];
        $basename = join(".",@parts[0..$nParts-3]);
      }
    } else {
      $uncompressedExtension = $extension;
      $basename = join(".",@parts[0..$nParts-2]);
    }
  }

  my $components = { directory=>$directory, basename=>$basename, extension=>$extension, uncompressedExtension=>$uncompressedExtension,
    isCompressed=>$isCompressed, filename=>$entry };

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $components;
}

###############################################################################
1;
