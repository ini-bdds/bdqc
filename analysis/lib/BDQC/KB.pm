package BDQC::KB;

###############################################################################
# Class       : BDQC::KB
#
# Description : This class is autogenerated via generatePerlClasses.pl and
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::KB';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';

#### BEGIN CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE

use BDQC::DataModel;

use BDQC::FileSignature::Generic;
use BDQC::FileSignature::Text;
use BDQC::FileSignature::Binary;
use BDQC::FileSignature::XML;
use BDQC::FileSignature::Tabular;

use Time::HiRes qw(gettimeofday tv_interval);
use File::Basename;

#### END CUSTOMIZED CLASS-LEVEL VARIABLES AND CODE


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Process constructor object parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_dataDirectory} = $dataDirectory;
  my $isChanged = processParameters( name=>'isChanged', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_isChanged} = $isChanged;
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_kbRootPath} = $kbRootPath;
  my $qckb = processParameters( name=>'qckb', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_qckb} = $qckb;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub getDataDirectory {
###############################################################################
# getDataDirectory
###############################################################################
  my $METHOD = 'getDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_dataDirectory});
}


sub setDataDirectory {
###############################################################################
# setDataDirectory
###############################################################################
  my $METHOD = 'setDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_dataDirectory} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getIsChanged {
###############################################################################
# getIsChanged
###############################################################################
  my $METHOD = 'getIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_isChanged});
}


sub setIsChanged {
###############################################################################
# setIsChanged
###############################################################################
  my $METHOD = 'setIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;

  #### Ensure that the value is of type int32
  unless ( $value =~ /^s*[\-\+]*\d+\s*$/ ) {
    print "ERROR: Unable to set isChanged to '$value': not valid int32\n";
  }


  $self->{_isChanged} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getKbRootPath {
###############################################################################
# getKbRootPath
###############################################################################
  my $METHOD = 'getKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_kbRootPath});
}


sub setKbRootPath {
###############################################################################
# setKbRootPath
###############################################################################
  my $METHOD = 'setKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_kbRootPath} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getQckb {
###############################################################################
# getQckb
###############################################################################
  my $METHOD = 'getQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_qckb});
}


sub setQckb {
###############################################################################
# setQckb
###############################################################################
  my $METHOD = 'setQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_qckb} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub calcModels {
###############################################################################
# calcModels
###############################################################################
  my $METHOD = 'calcModels';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating models for all available signatures");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### If the user specified some attributes to skip, create a hash of them
  my %attributesToSkip = ();
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  #### For each fileType, signature, and attribute, build a model of the observed data
  my $nOperations = 0;
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {
        next if ( $attributesToSkip{"$signature.$attribute"} );
        my $values = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{values};
        my $model;
        $model = BDQC::DataModel->new( vector=>$values );
        my $result = $model->create();
        $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model} = $result->{model};

	#### Add just the models without the datapoints or deviations to the models section
	foreach my $modelKey ( keys(%{$result->{model}}) ) {
	  next if ( $modelKey eq 'deviations' );
          $qckb->{models}->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model}->{$modelKey} = $result->{model}->{$modelKey};
        }

        $response->mergeResponse( sourceResponse=>$result );
        $nOperations++;
      }
    }
  }

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Calculate models of what seems normal for all $nOperations attributes of all signatures"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub calcSignatures {
###############################################################################
# calcSignatures
###############################################################################
  my $METHOD = 'calcSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating signatures for all new files");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  my %knownExtensions = (
#    "tsv" => { specificTypeName=>'tsv', genericType=>'tabular', signatureList=>[ "FileSignature::Tabular" ] },
#    "qlog" => { specificTypeName=>'qlog', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
#    "txt" => { specificTypeName=>'txt', genericType=>'txt', signatureList=>[ "FileSignature::Text" ] },
    "xml" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "mzML" => { specificTypeName=>'mzML', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "mzXML" => { specificTypeName=>'mzXML', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "bmp" => { specificTypeName=>'bmp', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "gif" => { specificTypeName=>'gif', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "png" => { specificTypeName=>'png', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "jpg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
#    "jpeg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
#    "JPG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
#    "JPEG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
  );

  eval {
    require XML::Parser;
  };
  if ( $@ ) {
    #print STDERR "XML::Parser not found, reverting to TXT analysis only\n";
    $knownExtensions{xml}->{signatureList} = [ "FileSignature::Text" ];
    $knownExtensions{mzML}->{signatureList} = [ "FileSignature::Text" ];
    $knownExtensions{mzXML}->{signatureList} = [ "FileSignature::Text" ];
  }

  my $nFiles = 0;
  my $nNewFiles = 0;
  my $totalFiles = scalar(keys(%{$qckb->{files}}));
  my $t0 = [gettimeofday];
  my $printedSomeProgressInfo = 0;

  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $filePath = $signatures->{tracking}->{filePath};
    my $knownExtension = $knownExtensions{$signatures->{extrinsic}->{uncompressedExtension}};
    my $fileTypeName = $signatures->{extrinsic}->{uncompressedExtension};

    #### If the file is not new, then we don't need to rerun the signature
    next if ( $signatures->{tracking}->{hasSignatures} );
    $nNewFiles++;

    #### Always run the FileSignature::Generic to help figure out what else to run on it
    my $genericSignature = BDQC::FileSignature::Generic->new( filePath=>$filePath );
    my $signatureName = "FileSignature::Generic";
    my $genericResult = $genericSignature->calcSignature();
    if ( $genericResult->{status} eq 'OK' ) {
      $signatures->{$signatureName} = $genericResult->{signature};
    } else {
      $response->mergeResponse( sourceResponse=>$genericResult );
      return $response;
    }

    #### Based on the results of FileSignature::Generic, decide what signatures to run
    my @signatureList;
    if ( $signatures->{"FileSignature::Generic"}->{fileType} eq 'binary' ) {
      @signatureList = ( 'FileSignature::Binary' );
    } elsif ( $signatures->{"FileSignature::Generic"}->{subFileType} eq 'xml' ) {
      #@signatureList = ( 'FileSignature::XML' );  # Too fragile. FIXME
      @signatureList = ( 'FileSignature::Text' );
    } elsif ( $signatures->{"FileSignature::Generic"}->{subFileType} eq 'tsv' ) {
      @signatureList = ( 'FileSignature::Tabular' );
    } elsif ( $signatures->{"FileSignature::Generic"}->{subFileType} eq 'json' ) {
      @signatureList = ( 'FileSignature::Text' );
    } elsif ( $signatures->{"FileSignature::Generic"}->{subFileType} eq 'code' ) {
      @signatureList = ( 'FileSignature::Text' );
    } elsif ( $signatures->{"FileSignature::Generic"}->{subFileType} eq 'plain' ) {
      @signatureList = ( 'FileSignature::Text' );
    } else {
      @signatureList = ( 'FileSignature::Text' );
    }

    #### If this is a known extension that should override what would be automatic, set it
    if ( $knownExtension ) {
      @signatureList = @{$knownExtension->{signatureList}};
      $fileTypeName = $knownExtension->{specificTypeName};
    }
    $signatures->{fileType}->{typeName} = $fileTypeName;

    #### Determine if there is some custom signatures that apply here, and update the signatureList
    if ( $qckb->{pluginSignatures} ) {
      foreach my $testFileTypeName ( ( "*all",$fileTypeName) ) {
        if ( $qckb->{pluginSignatures}->{$testFileTypeName} ) {
          if ( $qckb->{pluginSignatures}->{$testFileTypeName}->{set} ) {
            @signatureList = @{$qckb->{pluginSignatures}->{$testFileTypeName}->{set}};
          }
          if ( $qckb->{pluginSignatures}->{$testFileTypeName}->{add} ) {
            push(@signatureList, @{$qckb->{pluginSignatures}->{$testFileTypeName}->{add}});
          }
        }
      }
    }

    #### Loop over each signature to process and add the results
    foreach my $signatureName ( @signatureList ) {
      my $moduleName = "BDQC::$signatureName";
      my $result;

      #### If the signature is a BDQC module, then call that
      if ( $signatureName =~ /^FileSignature::/ ) {
	#next if ( $moduleName =~ /Tabular/ );
        #print "Running $moduleName on $filePath\n";
        my $signature = $moduleName->new( filePath=>$filePath );
        #my $t0 = [gettimeofday];
        $result = $signature->calcSignature();
        #my $t1 = [gettimeofday];
        #my $elapsed = tv_interval($t0,$t1);
        #print "$fileTag  $elapsed\n";

      #### Otherwise try to run it as an executable with the STDOUT captured as JSON
      } else {
        my @resultText = `$signatureName --filename $filePath`;
        $result = decode_json(join("\n",@resultText));
        if ( $result->{signatureName} ) {
          $signatureName = $result->{signatureName};
        }
      }

      if ( $result->{status} eq 'OK' ) {
        $signatures->{$signatureName} = $result->{signature};
      } else {
        $response->mergeResponse( sourceResponse=>$result );
        return $response;
      }
    }

    #### Record that this one has signatures calculated
    $signatures->{tracking}->{hasSignatures} = 1;

    #### Print some progress information
    unless ( $quiet ) {
      my $percentDone = int(( $nFiles/$totalFiles ) * 100);
      my $t1 = [gettimeofday];
      my $elapsed = tv_interval($t0,$t1);
      if ( $elapsed > 2 ) {
        print "$percentDone%..";
        $t0 = $t1;
	$printedSomeProgressInfo++;
      }
    }

  }

  print "\n" if ( $printedSomeProgressInfo );

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Calculated signatures for $nNewFiles new files", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Calculate signatures for $nNewFiles new files"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub collateData {
###############################################################################
# collateData
###############################################################################
  my $METHOD = 'collateData';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Collating all data from signatures into a matrix");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  my $nFiles = 0;
  my $allAttributes;

  #### Create a list of attributes that should not be collated, mostly because they're not useful or redundant
  my %attributesToSkip = (
    "fileType"=>1,
    "extrinsic.uncompressedExtension"=>1,
    "extrinsic.basename"=>1,
    "extrinsic.extension"=>1,
    "tracking.isNew"=>1,
    "tracking.hasSignatures"=>1,
    "tracking.hasBeenCollated"=>1,
    "tracking.fileTag"=>1,
    "tracking.dataDirectoryId"=>1,
    "tracking.filePath"=>1,
    "tracking.filename"=>1,
  );

  #### If the user specified some attributes to skip, add those
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  
  #### First scan through all the files and assign them to a fileType. Models will be built within fileTypes
  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {

    #### Get the signatures for this file and the fileTypeName (commonly a file extention)
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $fileTypeName = $signatures->{fileType}->{typeName};

    #### Check that $fileTypeName is valid
    unless ( $fileTypeName ) {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"MissingSignatures", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"FileTag '$fileTag' does not have a signature calculation yet. Need to run --calcSignatures first");
      return($response);
    }

    #### If this fileTypeName has not yet been added, do so
    unless ( $qckb->{fileTypes}->{$fileTypeName} ) {
      $qckb->{fileTypes}->{$fileTypeName} = { name=>$fileTypeName, fileTagList=>[], signatures=>{} };
    }

    #### If this is a new file, then add it to the file of files for this filetype
    unless ( $signatures->{tracking}->{hasBeenCollated} ) {
      push(@{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}},$fileTag);
      $signatures->{tracking}->{hasBeenCollated} = 1;
    }

    #### Also create a complete hash of all attributes for each signature
    foreach my $signature ( keys(%{$signatures}) ) {
      foreach my $attribute ( keys(%{$signatures->{$signature}}) ) {

        #### Check to see if this signature/attribute is one we should skip, or else add it to the list
        if ( $attributesToSkip{$signature} ) {
          #print "Don't bother collating all of signature $signature\n";
        } elsif ( $attributesToSkip{"$signature.$attribute"} ) {
          #print "Don't bother collating $signature.$attribute\n";
        } else {
          $allAttributes->{fileTypes}->{$fileTypeName}->{signatures}->{$signature}->{attributes}->{$attribute}++;
          #### Clear out any possible values from a previous run
          $qckb->{fileTypes}->{$fileTypeName}->{signatures}->{$signature}->{$attribute}->{values} = undef;
        }
      }
    }

    $nFiles++;
  }

  #### For each fileType, extract all the signatures for which we'll make a model
  foreach my $fileTypeName ( keys(%{$qckb->{fileTypes}}) ) {
    my $signatures = $qckb->{fileTypes}->{$fileTypeName}->{signatures};
    foreach my $fileTag ( @{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}} ) {
      foreach my $signature ( keys(%{$qckb->{files}->{$fileTag}->{signatures}}) ) {

        #### Loop over the complete list of all attributes we collected for this signature
        foreach my $attribute ( keys(%{$allAttributes->{fileTypes}->{$fileTypeName}->{signatures}->{$signature}->{attributes}}) ) {

          #### If we haven't encountered this attribute yet, then create an empty array
          unless ( $signatures->{$signature}->{$attribute}->{values} ) {
            $signatures->{$signature}->{$attribute}->{values} = [];
          }

          #### The fileAttribute starts as undef
          my $fileAttribute;
          #### See if it even exists for this file (it might not). If so, extract it
          if ( exists($qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute}) ) {
            $fileAttribute = $qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute};
          }
          #### Push whatever we found or didn't find onto the list. This list might have some nulls
          push(@{$signatures->{$signature}->{$attribute}->{values}},$fileAttribute);
        }
      }

      #### Make sure that new files are no longer tagged as new at this point
      #$qckb->{files}->{$fileTag}->{signatures}->{tracking}->{isNew} = 0;

    }
  }

  #### Create an entry in the updates log about what this did
  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => "Collated all the signatures from all files into a matrix for analysis"
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub createKb {
###############################################################################
# createKb
###############################################################################
  my $METHOD = 'createKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>1, message=>"Creating new BDQC KB for storing results", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create the qckb data structure and fill it with basic information
  my $qckb = {};
  $self->setQckb($qckb);
  $qckb->{kBtype} = "BDQC";
  $self->setIsChanged(1);

  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  $qckb->{startDate} = sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec);

  #### Empty array for updates
  $qckb->{updates} = [];
  $qckb->{models} = {};
  $qckb->{dataDirectories} = [];

  $qckb->{files} = {};
  $qckb->{fileTypes} = {};

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub getOutliers {
###############################################################################
# getOutliers
###############################################################################
  my $METHOD = 'getOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $astext = processParameters( name=>'astext', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $sensitivity = processParameters( name=>'sensitivity', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $skipAttributes = processParameters( name=>'skipAttributes', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Listing outliers in the BDQC KB");

  my $qckb = $self->getQckb();
  my $outliers;
  my $nOutlierFiles;

  #### If the user specified some attributes to skip, create a hash of them
  my %attributesToSkip = ();
  if ( $skipAttributes ) {
    my @attributes = split(/[,;]/,$skipAttributes);
    foreach my $attribute ( @attributes ) {
      $attributesToSkip{$attribute} = 1;
    }
  }

  #### Set the sensitivity for detection of outliers
  if ( $sensitivity ) {
    $sensitivity = 3 if ( $sensitivity =~ /high/i );
    $sensitivity = 5 if ( $sensitivity =~ /med(ium)*/i );
    $sensitivity = 10 if ( $sensitivity =~ /low/i );
    if ( $sensitivity !~ /\s*[\d\.]+\s*/ ) {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"InvalidSensitivity", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Specified sensitivity '$sensitivity' is not valid");
      return($response);
    }
  #### Else set the default sensitivity to 5 deviations
  } else {
    $sensitivity = 5;
  }

  #### For each fileType, signature, and attribute, record if any deviations are outliers
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    $outliers->{fileTypes}->{$fileType}->{nFiles} = 0;

    #### First, get the list of fileTagNames for this fileType
    my $fileTagNames = $qckb->{fileTypes}->{$fileType}->{fileTagList};

    #### Loop over the signatures and attributes
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {

        #### Skip this one if requested
        next if ( $attributesToSkip{"$signature.$attribute"} );

        #print "$signature.$attribute:\n";
        my $model = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model};

        #### Loop over all the deviations, looking for one labeled an outlier
        my $iDeviation = 0;
        foreach my $deviation ( @{$model->{deviations}} ) {
          if ( defined($deviation->{deviation}) && $deviation->{deviation} >= $sensitivity ) {

            #### Extract the datum and vaue for the outlier and condition a bit
            my $value = '(null)';
            my $datum = '(null)';
            $value = $deviation->{value} if ( defined($deviation->{value}) );
            $datum = $deviation->{datum} if ( defined($deviation->{datum}) );
            my $tmpText = "'$datum'";
            $tmpText .= " (with value $value)" if ( $datum ne $value );
            #print "  Datum $tmpText is an outlier with a deviation of '$deviation->{deviation}'\n";

            #### Store the information about this outlier
            my $fileTagName = $fileTagNames->[$iDeviation];
            my $outlierData = { signature=>$signature, attribute=>$attribute, datum=>$datum, value=>$value, deviation=>$deviation };
            push( @{$outliers->{fileTypes}->{$fileType}->{fileTags}->{$fileTagName}}, $outlierData );
            $outliers->{fileTypes}->{$fileType}->{nFiles}++;
          }
          $iDeviation++;
        } # end foreach deviation

      } # end foreach attribute

    } # end foreach signature

  } # end foreach fileType

  return $outliers if $astext;

  #### Print out the outlier files and their outlier values
  foreach my $fileType ( sort keys(%{$outliers->{fileTypes}}) ) {
    foreach my $outlierFileTagName ( sort keys(%{$outliers->{fileTypes}->{$fileType}->{fileTags}}) ) {
      print "$outlierFileTagName is an outlier because:\n";
      $nOutlierFiles++;
      my $outlierFileTagList = $outliers->{fileTypes}->{$fileType}->{fileTags}->{$outlierFileTagName};
      foreach my $outlier ( @{$outlierFileTagList} ) {
        my $signature = $outlier->{signature};
        my $attribute = $outlier->{attribute};
        my $value = $outlier->{value};
        my $deviation = $outlier->{deviation}->{deviation};
        $value = '(null)' if ( ! defined($value) );
        $value = substr($value,0,70)."...." if ( length($value)>74 );
	$deviation = sprintf("%.1f",$deviation);
        print "  $signature.$attribute: Value '$value' is an outlier at $deviation times typical deviation\n";
      }
    }
  }

  #### If there were none, print that
  unless ( $nOutlierFiles ) {
    print " - No outliers found\n";
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub importSignatures {
###############################################################################
# importSignatures
###############################################################################
  my $METHOD = 'importSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $importLimit = processParameters( name=>'importLimit', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $inputFile = processParameters( name=>'inputFile', required=>1, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### If the file exists, read it
  if ( -e $inputFile ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Importing BDQC data into KB from '$inputFile'");
    my $qckb =  $self->getQckb();

    if ( $inputFile =~ /\.gz$/ ) {
      $inputFile = "zcat $inputFile |";
    }

    if ( open(INFILE,$inputFile) ) {
      my $jsonData = '';
      while ( my $line = <INFILE> ) {
        $jsonData .= $line;
      }
      close(INFILE);
      my $inputBdqc = decode_json($jsonData);
      my $iFile = 0;
      foreach my $file ( keys(%{$inputBdqc}) ) {
        my $tmp = {};
        my $components = $self->splitFilePath($file);
        my $fileTag = "import1:$file";
        my $tracking = { fileTag=>$fileTag, filePath=>$file, filename=>$components->{filename},
          dataDirectory=>$components->{directory}, dataDirectoryId=>'import1', isNew=>1 };
        $tmp->{tracking} = $tracking;

        $tmp->{extrinsic}->{mtime} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{mtime};
        $tmp->{extrinsic}->{size} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{size};
        $tmp->{extrinsic}->{extension} = $components->{extension};
        $tmp->{extrinsic}->{uncompressedExtension} = $components->{uncompressedExtension};
        $tmp->{extrinsic}->{isCompressed} = $components->{isCompressed};
        $tmp->{extrinsic}->{filename} = $components->{filename};
        $tmp->{extrinsic}->{basename} = $components->{basename};
        $tmp->{extrinsic}->{readable} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{readable};
        $tmp->{fileType}->{typeName} = $components->{uncompressedExtension};

        #### Loop over all the other signatures and import them
        foreach my $signatureName ( keys(%{$inputBdqc->{$file}}) ) {
          #### Skip the ones that we've already translated by hand
          next if ( $signatureName eq 'bdqc.builtin.extrinsic' );
          next if ( $signatureName eq 'bdqc.builtin.filetype' );
          #### Loop over each attribute or container
          foreach my $attributeName ( keys(%{$inputBdqc->{$file}->{$signatureName}}) ) {
            my $attributeValue = $inputBdqc->{$file}->{$signatureName}->{$attributeName};

            #### If this attribute is already a scalar, then just store it
            if ( ref($attributeValue) eq '' ) {
              $tmp->{$signatureName}->{$attributeName} = $attributeValue;
              #print "Storing at base $signatureName.$attributeName = $attributeValue\n";
            #### Else if it complex, flatten it recursively into keys and values that are scalar, hash, or array
            } else {
              #print "Going complex!\n";
              my $flattenedAttributes = flattenAttributes($attributeName,$attributeValue);
              foreach my $flattenendAttributeName ( keys(%{$flattenedAttributes}) ) {
                #print "  Adding $signatureName.$flattenendAttributeName = $flattenedAttributes->{$flattenendAttributeName}\n";
                $tmp->{$signatureName}->{$flattenendAttributeName} = $flattenedAttributes->{$flattenendAttributeName};
              }
            }
              
          } # end foreach attributeName
        } # end foreach signatureName


        #delete($tmp->{signatures}->{"bdqc.builtin.tabular"});
        $qckb->{files}->{$fileTag}->{signatures} = $tmp;
        $iFile++;

        #### End early if requested
        if ( $importLimit ) {
          if ( $iFile >= $importLimit ) {
            $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
              message=>"Importing ended after $importLimit records as requested");
            last;
          }
        }
      }

      $self->setIsChanged(1);

      #### Create an entry in the updates log about what this did
      my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
      my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
        operation => $METHOD,
        comment => "Imported signatures from external file '$inputFile'"
      };
      push(@{$qckb->{updates}},$updateEntry);

    } else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileCannotBeOpened", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Input file '$inputFile' exists but cannot be opened.");
    }
    
  } else {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Input file '$inputFile' does not exist.");
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub loadKb {
###############################################################################
# loadKb
###############################################################################
  my $METHOD = 'loadKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $skipIfFileNotFound = processParameters( name=>'skipIfFileNotFound', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  $kbRootPath = $self->getKbRootPath();
  my $filename = "$kbRootPath.qckb.storable";

  #### Make sure the file exists
  if ( -e $filename ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Loading BDQC KB from '$filename'");
    my $qckb =  retrieve($filename);
    $self->setQckb($qckb);
    $self->setIsChanged(0);

  } else {
    if ( $skipIfFileNotFound ) {
      $response->setState( status=>'OK', message=>"Skipping IfFileNotFound as requested");
      $response->{fileNotFound} = 1;
    } else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"DatastoreDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Datastore '$filename' does not exist.");
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub parsePlugins {
###############################################################################
# parsePlugins
###############################################################################
  my $METHOD = 'parsePlugins';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $pluginModels = processParameters( name=>'pluginModels', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $pluginSignatures = processParameters( name=>'pluginSignatures', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();

  #### Plugin models are not yet supported
  if ( $pluginModels ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'pluginModelsNotYetSupported', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Although the option is listed, the option pluginModels is not yet written. Coming soon..");
    return $response;
  }

  #### Parse the pluginSignatures and if okay store in the KB
  if ( $pluginSignatures ) {
    my @commands = split(/;/,$pluginSignatures);
    foreach my $command ( @commands ) {
      my ($condition,$executable) = split(/=/,$command);
      if ( $condition && $executable ) {
        my ($fileType,$mode) = split(/:/,$condition);
        if ( $fileType && $mode ) {
          if ( -e $executable ) {
            push( @{$qckb->{pluginSignatures}->{$fileType}->{$mode}}, $executable);
          } else {
           $response->logEvent( level=>'WARNING', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
            message=>"Specified external plugin executable '$executable' does not exist as a single file, although might be a compound command");
            push( @{$qckb->{pluginSignatures}->{$fileType}->{$mode}}, $executable);
         }
        } else {
          $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'PluginSignatureMIssingColon', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
            message=>"Each pluginSignatures must have an = in it in the form condition=executable");
       }

      } else {
        $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'PluginSignatureMissingEqualSign', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
          message=>"Each pluginSignatures must have an = in it in the form condition=executable");
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub saveKb {
###############################################################################
# saveKb
###############################################################################
  my $METHOD = 'saveKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  my $qckb = $self->getQckb();
  $kbRootPath = $self->getKbRootPath();

  unless ( $self->getIsChanged() ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB has not changed. No need to save.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
    $response->setState( status=>'OK', message=>"No changes in the KB. No need to save.");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }


  #### First save the whole data structure as a Perl storable so it can be reloaded very rapidly
  my $filename = "$kbRootPath.qckb.storable";
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Saving BDQC KB to '$filename' and .json", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  store($qckb,$filename);
  $self->setIsChanged(0);

  #### Then also save the whole thing as a JSON file for developer inspection
  use JSON;
  my $json = JSON->new->allow_nonref;
  $json->canonical();
  my $buffer = $json->pretty->encode($qckb);
  $filename = "$kbRootPath.qckb.json";
  open(OUTFILE,">$filename");
  print OUTFILE $buffer;
  close(OUTFILE);

  #### Also write out just the models for later re-used
  $buffer = $json->pretty->encode($qckb->{models});
  $filename = "$kbRootPath.models.json";
  open(OUTFILE,">$filename");
  print OUTFILE $buffer;
  close(OUTFILE);

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB saved", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub scanDataPath {
###############################################################################
# scanDataPath
###############################################################################
  my $METHOD = 'scanDataPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($dataDirectory) ) {
    $dataDirectory = $self->getDataDirectory();
  } else {
    $self->setDataDirectory($dataDirectory);
  }

  my $inputFiles = processParameters( name=>'inputFiles', required=>0, allowUndef=>1, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### Make sure either dataDirectory or inputFiles is specified
  if ( $dataDirectory && $inputFiles ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'CantHaveBothDataDirectoryAndInputFiles', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Cannot specify both dataDirectory '$dataDirectory' and inputFiles '$inputFiles' in same invocation. Run first one then the other if both are needed.");
    return $response;
  }
  if ( ! $dataDirectory && ! $inputFiles ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'MustHaveEitherDataDirectoryOrInputFiles', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Must specify either dataDirectory or inputFiles");
    return $response;
  }

  #### If the dataDirectory was a Windows path, fix it
  if ( $dataDirectory && $dataDirectory =~ /\\/ ) {
    $dataDirectory =~ s/\\/\//g;
    $self->setDataDirectory($dataDirectory);
  }
  if ( $inputFiles && $inputFiles =~ /\\/ ) {
    $inputFiles =~ s/\\/\//g;
  }


  my %stats = ( totalFiles=>0, newFiles=>0, totalSize=>0 );

  #### Set up a directoryId
  my $dataDirectoryId = '';
  my $nPreviousDirectories = scalar(@{$qckb->{dataDirectories}});


  #### Verify that the specified directory exists and is a directory
  if ( $dataDirectory ) {
    if ( ! -e $dataDirectory ) {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'DataDirecoryNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Data directory '$dataDirectory' is not found");
      return $response;
    } elsif ( ! -d $dataDirectory ) {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'SpecifiedDataDirecoryNotADirectory', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Data directory '$dataDirectory' is  found but is not a directory");
      return $response;
    }

    #### See if this dataDirectory has already been scanned
    foreach my $previousDirectories ( @{$qckb->{dataDirectories}} ) {
      if ( $previousDirectories->{path} eq $dataDirectory ) {
        $dataDirectoryId = $previousDirectories->{id};
      }
    }

  }

  #### Put this directory on the stack and work on it
  my @directoriesToProcess;
  if ( $dataDirectory ) {
    @directoriesToProcess = ( $dataDirectory );
  }

  #### If the input is inputFiles, then load that
  my $sourceListFile = '';
  if ( $inputFiles ) {
    if ( -f $inputFiles ) {
      open(INFILE,$inputFiles);
      $sourceListFile = $inputFiles;

      #### See if this same file was already scanned once, in which case, switch to that source id
      foreach my $previousFiles ( @{$qckb->{dataDirectories}} ) {
	if ( $previousFiles && $previousFiles->{sourceListFile} ) {
	  if ( $previousFiles->{sourceListFile} eq $inputFiles ) {
	    $dataDirectoryId = $previousFiles->{id};
	  }
        }
      }

      while ( my $line = <INFILE> ) {
        $line =~ s/[\n\r]+$//;
        next unless ( $line );
        push(@directoriesToProcess,$line);
        #print "  - Adding $line\n";
      }
    } else {
      @directoriesToProcess = glob($inputFiles);
      #print "Glob of 'inputFiles' resolved to:\n  - ".join("\n  - ",@directoriesToProcess)."\n";
    }
  }

  #### If we haven't scanned this one before, add this path now
  unless ( $dataDirectoryId ) {
    $nPreviousDirectories++;
    $dataDirectoryId = "dir$nPreviousDirectories";
    my $tmpContent = { id=>$dataDirectoryId };
    $tmpContent->{path} = $dataDirectory if ( $dataDirectory );
    $tmpContent->{sourceListFile} = $sourceListFile if ( $sourceListFile );
    push(@{$qckb->{dataDirectories}}, $tmpContent);
  }


  #### Loop over the directories and files to work on
  my $done = 0;
  my @additionalDirectories;
  while ( ! $done ) {

    #### Get the next thing to do or finish
    my $directory = shift(@directoriesToProcess);
    my $additionalDirectoriesFlag = 0;
    unless ( $directory ) {
      $directory = shift(@additionalDirectories);
      $additionalDirectoriesFlag = 1;
      #print "Processing additional directory '$directory'\n" if ( $directory );
    }
    last unless ( $directory );

    my @entries;
    if ( -d $directory ) {
      #### If this was found with a glob and is not an additional directory, defer it to later
      if ( $inputFiles && ! $additionalDirectoriesFlag ) {
        push(@additionalDirectories,$directory);
	next;

      #### Otherwise read the directory and process the contents
      } else {
        opendir(DIR,$directory) || die("ERROR: Unable to open directory '$directory'");
        @entries = grep(!/^\.{1,2}$/, readdir(DIR));
        closedir(DIR);
        @entries = sort(@entries);
      }

    #### Or if the directory is actually a file, then just process it
    } elsif ( -f $directory ) {
      push(@entries,$directory);
      #$directory = '';
    }

    #### Loop over all the entries from the directory
    foreach my $entry ( @entries ) {
      my $fileTag = "";
      my $filePath = "";

      #### If we're in the dataDirectory mode, process files but push more directories
      if ( $dataDirectory || $additionalDirectoriesFlag ) {
        if ( -f "$directory/$entry" ) {
          $fileTag = "$dataDirectoryId:$directory/$entry";
          $filePath = "$directory/$entry";
        } elsif ( -d "$directory/$entry" ) {
          push(@additionalDirectories,"$directory/$entry");
	  next;
        } else {
          print "Do not know what to do with $directory/$entry\n";
	  next;
        }
      
      #### Otherwise if we're in inputFiles mode, process files and push directories
      } elsif ( $inputFiles && ! $additionalDirectoriesFlag ) {
        if ( -f $entry ) {
          $fileTag = "$dataDirectoryId:$entry";
          $filePath = "$entry";
        } elsif ( -d "$directory/$entry" ) {
          push(@additionalDirectories,"$directory/$entry");
	  next;
        } else {
          print "Do not know what to do with $entry\n";
	  next;
        }
      }

      $stats{totalFiles}++;

      #### Parse the filename into pieces
      my @parts = split(/\./,$entry);
      my $nParts = scalar(@parts);
      my $basename = '';
      my $extension = '';
      my $uncompressedExtension = '';
      my $isCompressed = 0;
      if ( $nParts == 1) {
        $basename = $entry;
      } else {
        $extension = $parts[$nParts-1];
        my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
        if ( $compressedExtensions{$extension} ) {
          $isCompressed = 1;
          if ( $nParts == 2 ) {
            $basename = $parts[0];
          } else {
            $uncompressedExtension = $parts[$nParts-2];
            $basename = join(".",@parts[0..$nParts-3]);
          }
        } else {
          $uncompressedExtension = $extension;
          $basename = join(".",@parts[0..$nParts-2]);
        }
      }

      my $tracking = { fileTag=>$fileTag, filePath=>$filePath, filename=>$entry, dataDirectory=>$dataDirectory, dataDirectoryId=>$dataDirectoryId };
      my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($filePath);
      $size = 0 if ( ! defined($size) );
      $mtime = 0 if ( ! defined($mtime) );
      $mode = 0 if ( ! defined($mode) );
      $stats{totalSize} += $size;

      if ( exists($qckb->{files}->{$fileTag}) ) {

	#### If this file has already been previously processed, then remove the isNew flag
	my $signatures = $qckb->{files}->{$fileTag}->{signatures};
	if ( $signatures->{tracking}->{hasSignatures} && $signatures->{tracking}->{hasBeenCollated} ) {
          $tracking->{isNew} = 0;
          $qckb->{files}->{$fileTag}->{signatures}->{tracking}->{isNew} = 0;
        }

        if ( $mtime ne $qckb->{files}->{$fileTag}->{signatures}->{extrinsic}->{mtime} ) {
          $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isChanged} = 1;
        }
      } else {
        $tracking->{isNew} = 1;
        $stats{newFiles}++;
        $qckb->{files}->{$fileTag} ->{signatures}->{tracking} = $tracking;
        my $extrinsic = { filename=>$entry, mtime=>$mtime, size=>$size, mode=>$mode, extension=>$extension, iscompressed=>$isCompressed, uncompressedExtension=>$uncompressedExtension, basename=>$basename };
        $qckb->{files}->{$fileTag}->{signatures}->{extrinsic} = $extrinsic;
      }

    }
  }

  $response->{stats} = \%stats;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"$stats{totalFiles} files ($stats{totalSize} bytes) scanned. $stats{newFiles} files are new to this scan.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create an entry in the updates log about what this did
  my $comment;
  if ( $dataDirectory ) {
    $comment = "Scanned data directory '$dataDirectory' and added $stats{newFiles} new files";
  } else {
    $comment = "Scanned files contained in '$inputFiles' and added $stats{newFiles} new files";
  }

  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  my $updateEntry = { datetime=>sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec),
    operation => $METHOD,
    comment => $comment
  };
  push(@{$qckb->{updates}},$updateEntry);

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub show {
###############################################################################
# show
###############################################################################
  my $METHOD = 'show';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Create a simple text representation of the data in the object
  my $buffer = '';
  $buffer .= "$self\n";
  my $dataDirectory = $self->getDataDirectory() || '';
  $buffer .= "  dataDirectory=$dataDirectory\n";
  my $isChanged = $self->getIsChanged() || '';
  $buffer .= "  isChanged=$isChanged\n";
  my $kbRootPath = $self->getKbRootPath() || '';
  $buffer .= "  kbRootPath=$kbRootPath\n";
  my $qckb = $self->getQckb() || '';
  $buffer .= "  qckb=$qckb\n";

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $buffer;
}


sub flattenAttributes {
###############################################################################
# flattenAttributes
# Reduce the depth of attributes to the top level, except permit hashes and
# arrays of scalars
###############################################################################
  my ($attributeName,$attributeValue) = @_;

  my $result;

  #### If the passed attributeValue is just a scalar, then record it as is (probably should never happen?)
  if ( ref($attributeValue) eq '' || ref($attributeValue) eq 'JSON::PP::Boolean' ) {
    $result->{attributeName} = $attributeValue;

  #### Else if this is a HASH then process it
  } elsif ( ref($attributeValue) eq 'HASH' ) {

    #### First loop through to see if they're all scalars or not
    my $allAreScalars = 1;
    foreach my $key ( keys(%{$attributeValue}) ) {
      my $value = $attributeValue->{$key};
      if ( ref($value) ne '' && ref($value) ne 'JSON::PP::Boolean' ) {
        $allAreScalars = 0;
      }
    }
      
    #### If they're all scalars, then return this as a histogram as is
    if ( $allAreScalars ) {
      $result->{$attributeName} = $attributeValue;

    #### But if at least one is complex, then record the scalars as attributes and recurse into the complex ones
    } else {
      foreach my $key ( keys(%{$attributeValue}) ) {
        my $value = $attributeValue->{$key};
        if ( ref($value) eq '' || ref($value) eq 'JSON::PP::Boolean' ) {
          $result->{"$attributeName.$key"} = $value;
        } else {
          my $recursedResult = flattenAttributes("$attributeName.$key",$value);
          foreach my $recursedKey ( keys(%{$recursedResult}) ) {
            $result->{$recursedKey} = $recursedResult->{$recursedKey};
          }
        }
      }
    }

  #### Else if this is an ARRAY then process it
  } elsif ( ref($attributeValue) eq 'ARRAY' ) {

    #### First loop through to see if they're all scalars or not
    my $allAreScalars = 1;
    foreach my $value ( @{$attributeValue} ) {
      if ( ref($value) ne '' && ref($value) ne 'JSON::PP::Boolean' ) {
        $allAreScalars = 0;
      }
    }
      
    #### If they're all scalars, then return this as a histogram as is
    if ( $allAreScalars ) {
      $result->{$attributeName} = $attributeValue;

    #### But if at least one is complex, then record the scalars as attributes and recurse into the complex ones
    } else {
      my $i = 0;
      foreach my $value ( @{$attributeValue} ) {
        if ( ref($value) eq '' || ref($value) eq 'JSON::PP::Boolean' ) {
          $result->{"$attributeName.$i"} = $value;
        } else {
          my $recursedResult = flattenAttributes("$attributeName.$i",$value);
          foreach my $recursedKey ( keys(%{$recursedResult}) ) {
            $result->{$recursedKey} = $recursedResult->{$recursedKey};
          }
        }
        $i++;
      }
    }

  }
  
  return $result;
}
###############################################################################
# parseModels
sub parseModels {
  my $self = shift || die ("Must be called as an object method");
  my %opts = @_;
  die unless $opts{kb};

  my $qckb = $opts{kb}->{_qckb};
  my %models;

  # Loop over data structure.  File type
  for my $ft ( keys( %{$qckb->{fileTypes}} ) ) {
    $models{$ft} = {};

    my @files;
    # Under type read list of files
    for my $tag ( @{$qckb->{fileTypes}->{$ft}->{fileTagList}} ) {
      push @files, basename( $tag );
    }
    $models{$ft}->{files} = \@files;

    # Then Signature
    for my $sig ( keys( %{$qckb->{fileTypes}->{$ft}->{signatures}} ) ) {
      my $sig_obj = $qckb->{fileTypes}->{$ft}->{signatures}->{$sig};

      # Then individual 'Elements'
      for my $sigelem ( keys( %{$sig_obj} ) ) {
        my $has_outliers = 0;
        my $has_deviation = 0;
        my @dev;

        next unless $sig_obj->{$sigelem}->{model}->{deviations};

        my $fidx = 0;
        for my $dev ( @{$sig_obj->{$sigelem}->{model}->{deviations}} ) {
          last unless defined ( $dev->{deviationFlag} );
          $has_deviation++;
          if ( $dev->{deviationFlag} !~ /^normal$/i ) {
            $has_outliers++;
          }
          $dev->{filename} = $files[$fidx];
          push @dev, $dev;
          $fidx++;
        }

        my $mkey = $sig . '.' . $sigelem;
        $mkey =~ s/FileSignature::/FS/;

#        next unless $has_outliers;
        next unless $has_deviation;

        $models{$ft}->{$mkey} = { hasout => $has_outliers,
                                    data => \@dev };
      }
    }
  }
  return \%models;
}
sub splitFilePath {
###############################################################################
# splitFilePath
###############################################################################
  my $METHOD = 'splitFilePath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my $filePath = shift;

  my %components;

  #### Parse off the directory
  my @pathParts = split(/\//,$filePath);
  my $directory = join("\/",@pathParts[0..($#pathParts-1)]);
  my $entry = $pathParts[$#pathParts];

  #### Parse the filename into pieces
  my @parts = split(/\./,$entry);
  my $nParts = scalar(@parts);
  my $basename = '';
  my $extension = '';
  my $uncompressedExtension = '';
  my $isCompressed = 0;
  if ( $nParts == 1) {
    $basename = $entry;
  } else {
    $extension = $parts[$nParts-1];
    my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
    if ( $compressedExtensions{$extension} ) {
      $isCompressed = 1;
      if ( $nParts == 2 ) {
        $basename = $parts[0];
      } else {
        $uncompressedExtension = $parts[$nParts-2];
        $basename = join(".",@parts[0..$nParts-3]);
      }
    } else {
      $uncompressedExtension = $extension;
      $basename = join(".",@parts[0..$nParts-2]);
    }
  }

  my $components = { directory=>$directory, basename=>$basename, extension=>$extension, uncompressedExtension=>$uncompressedExtension,
    isCompressed=>$isCompressed, filename=>$entry };

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $components;
}

###############################################################################
1;
